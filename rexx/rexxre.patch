diff -ruN rexxre/FIXES rexxre-patch/FIXES
--- rexxre/FIXES	2003-05-26 13:44:04.000000000 +1200
+++ rexxre-patch/FIXES	1970-01-01 13:00:00.000000000 +1300
@@ -1,6 +0,0 @@
-List of changes
-
-1.0.1	significant changes to ReParse(): removes hang when the delimiter
-	or field RE matches a zero-length string.
-	Added Rexx/Trans and OS/2 binaries to main distribution.
-1.0.0	initial revision
diff -ruN rexxre/Makefile.Mingw rexxre-patch/Makefile.Mingw
--- rexxre/Makefile.Mingw	2003-04-29 10:57:30.000000000 +1200
+++ rexxre-patch/Makefile.Mingw	1970-01-01 13:00:00.000000000 +1300
@@ -1,69 +0,0 @@
-# Win32 Makefile for RexxRE
-# this makefile works with mingw gcc
-# you are meant to copy Makefile.mingw to the name Makefile, and
-# then type `make dist' to get an optimised version of the library
-
-#  The contents of this file are subject to the Mozilla Public License
-#  Version 1.1 (the "License"); you may not use this file except in
-#  compliance with the License. You may obtain a copy of the License at
-#  http://www.mozilla.org/MPL/
-
-#  Software distributed under the License is distributed on an "AS IS"
-#  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
-#  License for the specific language governing rights and limitations
-#  under the License.
-
-#  The Original Code is RexxRE.
-
-#  The Initial Developer of the Original Code is Patrick TJ McPhee.
-#  Portions created by Patrick McPhee are Copyright © 2003
-#  Patrick TJ McPhee. All Rights Reserved.
-
-#  Contributors:
-
-# $Header: C:/ptjm/rexx/rexxre/RCS/Makefile.Mingw 1.2 2003/04/29 15:57:30 ptjm Rel $
-
-DEBUG=-g
-DOPT=-O2 -fno-stack-check -fomit-frame-pointer -fexpensive-optimizations -mcpu=pentiumpro
-INCDIR=../regina
-LIBDIR=../regina
-CDEFS=
-CFLAGS=$(OPT) $(DEBUG) $(CDEFS) -pipe -I$(INCDIR) -Iregex -mdll
-LDFLAGS=-Wl,--enable-stdcall-fixup,--major-image-version=1,--minor-image-version=0 -s -L$(LIBDIR)
-CC=gcc
-
-PROJECT=rexxre
-
-
-OBJS=$(PROJECT).o regcomp.o regexec.o regerror.o\
- regfree.o rxsupport.o $(PROJECT)res.o
-
-$(PROJECT).dll : $(OBJS) $(PROJECT).def
-	$(CC) $(CFLAGS) $(LDFLAGS) -o$(PROJECT).dll $(OBJS) $(PROJECT).def -lregina
-
-$(PROJECT)res.o : $(PROJECT).rc
-	windres $(PROJECT).rc $(PROJECT)res.o
-
-regcomp.o : regex/regcomp.c
-	$(CC) -c $(CFLAGS) regex/regcomp.c
-
-regexec.o : regex/regexec.c
-	$(CC) -c $(CFLAGS) regex/regexec.c
-
-regfree.o : regex/regfree.c
-	$(CC) -c $(CFLAGS) regex/regfree.c
-
-regerror.o : regex/regerror.c
-	$(CC) -c $(CFLAGS) regex/regerror.c
-
-
-dist:
-	$(MAKE) $(MAKEFLAGS) OPT="$(DOPT)" DEBUG=""
-
-
-clean:
-	-rm *.o
-	-rm *.lib
-	-rm *.dll
-	-rm *.exp
-
diff -ruN rexxre/Makefile.NT rexxre-patch/Makefile.NT
--- rexxre/Makefile.NT	2003-04-29 10:57:34.000000000 +1200
+++ rexxre-patch/Makefile.NT	1970-01-01 13:00:00.000000000 +1300
@@ -1,62 +0,0 @@
-# Win32 Makefile for RexxRE
-# this makefile works with the microsoft visual c compiler
-# you are meant to copy Makefile.nt to the name Makefile, and
-# then type `make dist' to get an optimised version of the library
-
-#  The contents of this file are subject to the Mozilla Public License
-#  Version 1.1 (the "License"); you may not use this file except in
-#  compliance with the License. You may obtain a copy of the License at
-#  http://www.mozilla.org/MPL/
-
-#  Software distributed under the License is distributed on an "AS IS"
-#  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
-#  License for the specific language governing rights and limitations
-#  under the License.
-
-#  The Original Code is RexxRE.
-
-#  The Initial Developer of the Original Code is Patrick TJ McPhee.
-#  Portions created by Patrick McPhee are Copyright © 2003
-#  Patrick TJ McPhee. All Rights Reserved.
-
-#  Contributors:
-
-# $Header: C:/ptjm/rexx/rexxre/RCS/Makefile.NT 1.2 2003/04/29 15:57:33 ptjm Rel $
-
-DEBUG=-Zi
-DOPT=-Ox -G6
-INCDIR=../regina
-LIBDIR=..\regina
-CDEFS=
-CFLAGS=$(OPT) $(DEBUG) $(CDEFS) -nologo -GF -I$(INCDIR) -Iregex -MD
-LDFLAGS=-LD $(OPT) $(DEBUG) -MD
-CC=cl
-
-PROJECT=rexxre
-
-
-OBJS=$(PROJECT).obj regcomp.obj regexec.obj regerror.obj\
- regfree.obj rxsupport.obj $(PROJECT).res
-
-$(PROJECT).dll : $(OBJS) $(PROJECT).def
-	$(CC) $(CFLAGS) $(LDFLAGS) -Fe$(PROJECT).dll $(OBJS) $(PROJECT).def $(LIBDIR)\regina.lib
-
-regcomp.obj : regex/regcomp.c
-	$(CC) -c $(CFLAGS) regex/regcomp.c
-
-regexec.obj : regex/regexec.c
-	$(CC) -c $(CFLAGS) regex/regexec.c
-
-regfree.obj : regex/regfree.c
-	$(CC) -c $(CFLAGS) regex/regfree.c
-
-regerror.obj : regex/regerror.c
-	$(CC) -c $(CFLAGS) regex/regerror.c
-
-
-dist:
-	$(MAKE) $(MAKEFLAGS) OPT="$(DOPT)" DEBUG=""
-
-
-clean:
-	del /f *.obj *.pdb *.lib *.dll *.exp *.ilk *.res
diff -ruN rexxre/Makefile.aix rexxre-patch/Makefile.aix
--- rexxre/Makefile.aix	2003-04-29 11:05:24.000000000 +1200
+++ rexxre-patch/Makefile.aix	1970-01-01 13:00:00.000000000 +1300
@@ -1,37 +0,0 @@
-# AIX Makefile for RexxRE
-
-#  The contents of this file are subject to the Mozilla Public License
-#  Version 1.1 (the "License"); you may not use this file except in
-#  compliance with the License. You may obtain a copy of the License at
-#  http://www.mozilla.org/MPL/
-
-#  Software distributed under the License is distributed on an "AS IS"
-#  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
-#  License for the specific language governing rights and limitations
-#  under the License.
-
-#  The Original Code is RexxRE.
-
-#  The Initial Developer of the Original Code is Patrick TJ McPhee.
-#  Portions created by Patrick McPhee are Copyright © 2003
-#  Patrick TJ McPhee. All Rights Reserved.
-
-#  Contributors:
-
-# $Header: C:/ptjm/rexx/rexxre/RCS/Makefile.aix 1.1 2003/04/29 16:05:24 ptjm Rel $
-
-# flags for IBM's C compiler
-POPT=-O
-PCDEFS=
-PCFLAGS=-fPIC -qro -qroconst
-PLDFLAGS=-bnoentry -bE:librexxre.exp -bM:SRE -T512 -H512 -lc -L$(HOME)/regina -lregina
-PLIBS=
-PCLEAN=librexxre.exp librexxre.so
-
-librexxre.a : librexxre.exp librexxre.so
-	ln -f librexxre.so librexxre.a
-
-librexxre.exp : rexxre.def
-	awk '/EXPORTS/ { print $$2 }' rexxre.def > librexxre.exp 
-
-include Makefile.inc
diff -ruN rexxre/Makefile.bsd rexxre-patch/Makefile.bsd
--- rexxre/Makefile.bsd	2003-04-29 11:07:44.000000000 +1200
+++ rexxre-patch/Makefile.bsd	1970-01-01 13:00:00.000000000 +1300
@@ -1,28 +0,0 @@
-# FreeBSD Makefile for RexxRE
-#  The contents of this file are subject to the Mozilla Public License
-#  Version 1.1 (the "License"); you may not use this file except in
-#  compliance with the License. You may obtain a copy of the License at
-#  http://www.mozilla.org/MPL/
-
-#  Software distributed under the License is distributed on an "AS IS"
-#  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
-#  License for the specific language governing rights and limitations
-#  under the License.
-
-#  The Original Code is RexxRE.
-
-#  The Initial Developer of the Original Code is Patrick TJ McPhee.
-#  Portions created by Patrick McPhee are Copyright © 2003
-#  Patrick TJ McPhee. All Rights Reserved.
-
-#  Contributors:
-
-# $Header: C:/ptjm/rexx/rexxre/RCS/Makefile.bsd 1.1 2003/04/29 16:07:44 ptjm Rel $
-
-POPT=-O2 -fomit-frame-pointer
-PCDEFS=
-PCFLAGS=-fpic -pipe
-PLDFLAGS=-Bdynamic -Bshareable
-PLIBS=
-
-include Makefile.inc
diff -ruN rexxre/Makefile.doc rexxre-patch/Makefile.doc
--- rexxre/Makefile.doc	2003-05-26 14:35:34.000000000 +1200
+++ rexxre-patch/Makefile.doc	1970-01-01 13:00:00.000000000 +1300
@@ -1,24 +0,0 @@
-# Copyright 2003 Patrick TJ McPhee
-# Distributed under the terms of the Mozilla Public Licence
-# You can obtain a copy of the licence at http://www.mozilla.org/MPL
-# The Original Code is RexxRE
-# The Initial Developer is Patrick TJ McPhee
-# $Header: C:/ptjm/rexx/rexxre/RCS/Makefile.doc 1.2 2003/05/26 19:35:34 ptjm Rel $
-
-# this makefile produces the .pdf documentation. It requires pdflatex
-# (v.14g or later). On win32 systems, you'll need rm to run the clean
-# target 
-
-PROJECT=rexxre
-
-doc : $(PROJECT).pdf
-
-
-# need to do this three times to get congruence
-$(PROJECT).pdf : $(PROJECT).tex
-	pdflatex $(PROJECT)
-	pdflatex $(PROJECT)
-	pdflatex $(PROJECT)
-
-clean :
-	-rm $(PROJECT).pdf $(PROJECT).log $(PROJECT).aux $(PROJECT).toc $(PROJECT).out
diff -ruN rexxre/Makefile.emx rexxre-patch/Makefile.emx
--- rexxre/Makefile.emx	2003-05-01 10:57:58.000000000 +1200
+++ rexxre-patch/Makefile.emx	1970-01-01 13:00:00.000000000 +1300
@@ -1,67 +0,0 @@
-# OS/2 Makefile for RexxRE
-# this makefile works with emx gcc
-# you are meant to copy Makefile.emx to the name Makefile, and
-# then type `make dist' to get an optimised version of the library
-# the resulting library does not require the EMX runtime
-
-#  The contents of this file are subject to the Mozilla Public License
-#  Version 1.1 (the "License"); you may not use this file except in
-#  compliance with the License. You may obtain a copy of the License at
-#  http://www.mozilla.org/MPL/
-
-#  Software distributed under the License is distributed on an "AS IS"
-#  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
-#  License for the specific language governing rights and limitations
-#  under the License.
-
-#  The Original Code is RexxRE.
-
-#  The Initial Developer of the Original Code is Patrick TJ McPhee.
-#  Portions created by Patrick McPhee are Copyright © 2003
-#  Patrick TJ McPhee. All Rights Reserved.
-
-#  Contributors:
-
-# $Header: C:/ptjm/rexx/rexxre/RCS/Makefile.emx 1.1 2003/05/01 15:57:58 ptjm Rel $
-
-DEBUG=-g
-DOPT=-O2 -fno-stack-check -fomit-frame-pointer -fexpensive-optimizations -mcpu=pentiumpro
-CDEFS=
-CFLAGS=$(OPT) $(DEBUG) $(CDEFS) -pipe -Iregex -Zsys -Zdll -Zomf
-LDFLAGS=-s
-CC=gcc
-
-PROJECT=rexxre
-
-
-OBJS=$(PROJECT).obj regcomp.obj regexec.obj regerror.obj\
- regfree.obj rxsupport.obj
-
-$(PROJECT).dll : $(OBJS) $(PROJECT).def
-	$(CC) $(CFLAGS) $(LDFLAGS) -o$(PROJECT).dll $(OBJS) $(PROJECT).def
-
-regcomp.obj : regex/regcomp.c
-	$(CC) -c $(CFLAGS) regex/regcomp.c
-
-regexec.obj : regex/regexec.c
-	$(CC) -c $(CFLAGS) regex/regexec.c
-
-regfree.obj : regex/regfree.c
-	$(CC) -c $(CFLAGS) regex/regfree.c
-
-regerror.obj : regex/regerror.c
-	$(CC) -c $(CFLAGS) regex/regerror.c
-
-%.obj : %.c
-	$(CC) $(CFLAGS) -c $<
-
-dist:
-	$(MAKE) $(MAKEFLAGS) OPT="$(DOPT)" DEBUG=""
-
-
-clean:
-	-rm *.obj
-	-rm *.lib
-	-rm *.dll
-	-rm *.exp
-
diff -ruN rexxre/Makefile.hp rexxre-patch/Makefile.hp
--- rexxre/Makefile.hp	2003-04-29 11:09:36.000000000 +1200
+++ rexxre-patch/Makefile.hp	1970-01-01 13:00:00.000000000 +1300
@@ -1,35 +0,0 @@
-# HP-UX Makefile for RexxRE
-#  The contents of this file are subject to the Mozilla Public License
-#  Version 1.1 (the "License"); you may not use this file except in
-#  compliance with the License. You may obtain a copy of the License at
-#  http://www.mozilla.org/MPL/
-
-#  Software distributed under the License is distributed on an "AS IS"
-#  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
-#  License for the specific language governing rights and limitations
-#  under the License.
-
-#  The Original Code is RexxRE.
-
-#  The Initial Developer of the Original Code is Patrick TJ McPhee.
-#  Portions created by Patrick McPhee are Copyright © 2003
-#  Patrick TJ McPhee. All Rights Reserved.
-
-#  Contributors:
-
-# $Header: C:/ptjm/rexx/rexxre/RCS/Makefile.hp 1.1 2003/04/29 16:09:36 ptjm Rel $
-
-POPT=-O3
-PCDEFS=
-PCFLAGS=+z +ESlit -Ae
-PLDFLAGS=-b
-PLIBS=
-PCLEAN=librexxre.sl
-
-librexxre.sl : librexxre.so
-	ln -f librexxre.so librexxre.sl
-
-include Makefile.inc
-
-%.o : %.c
-	$(CC) $(CFLAGS) -c $<
diff -ruN rexxre/Makefile.inc rexxre-patch/Makefile.inc
--- rexxre/Makefile.inc	2003-04-29 11:16:36.000000000 +1200
+++ rexxre-patch/Makefile.inc	1970-01-01 13:00:00.000000000 +1300
@@ -1,49 +0,0 @@
-# Unix Makefile for RexxRE
-
-# You are meant to set the P variables (PDEBUG et al) in a platform-
-# specific Makefile, then include Makefile.inc from that other file
-
-#  The contents of this file are subject to the Mozilla Public License
-#  Version 1.1 (the "License"); you may not use this file except in
-#  compliance with the License. You may obtain a copy of the License at
-#  http://www.mozilla.org/MPL/
-
-#  Software distributed under the License is distributed on an "AS IS"
-#  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
-#  License for the specific language governing rights and limitations
-#  under the License.
-
-#  The Original Code is RexxRE.
-
-#  The Initial Developer of the Original Code is Patrick TJ McPhee.
-#  Portions created by Patrick McPhee are Copyright © 2003
-#  Patrick TJ McPhee. All Rights Reserved.
-
-#  Contributors:
-
-# $Header: C:/ptjm/rexx/rexxre/RCS/Makefile.inc 1.1 2003/04/29 16:16:36 ptjm Rel $
-
-DEBUG=-g $(PDEBUG)
-OPT=
-
-REXX_INCLUDE=$(HOME)/regina
-CFLAGS=$(DEBUG) $(OPT) $(PCFLAGS) $(PCDEFS) -I $(REXX_INCLUDE)
-LDFLAGS=$(PLDFLAGS)
-LIBS=$(PLIBS)
-PROJECT=rexxre
-LIBFILE=lib$(PROJECT).so
-
-OBJS=$(PROJECT).o rxsupport.o
-
-$(LIBFILE) : $(OBJS)
-	$(LD) $(LDFLAGS) -o$(LIBFILE) $(OBJS)
-
-
-dist:
-	$(MAKE) $(MAKEFLAGS) OPT="$(POPT)" DEBUG=""
-
-
-clean:
-	-rm $(OBJS) $(LIBFILE) $(PCLEAN)
-
-
diff -ruN rexxre/Makefile.linux rexxre-patch/Makefile.linux
--- rexxre/Makefile.linux	2003-04-29 11:07:26.000000000 +1200
+++ rexxre-patch/Makefile.linux	1970-01-01 13:00:00.000000000 +1300
@@ -1,28 +0,0 @@
-# Linux Makefile for RexxRE
-#  The contents of this file are subject to the Mozilla Public License
-#  Version 1.0 (the "License"); you may not use this file except in
-#  compliance with the License. You may obtain a copy of the License at
-#  http://www.mozilla.org/MPL/
-
-#  Software distributed under the License is distributed on an "AS IS"
-#  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
-#  License for the specific language governing rights and limitations
-#  under the License.
-
-#  The Original Code is RexxRE.
-
-#  The Initial Developer of the Original Code is Patrick TJ McPhee.
-#  Portions created by Patrick McPhee are Copyright © 1999, 2001
-#  Patrick TJ McPhee. All Rights Reserved.
-
-#  Contributors:
-
-# $Header: C:/ptjm/rexx/rexxre/RCS/Makefile.linux 1.1 2003/04/29 16:07:26 ptjm Rel $
-
-POPT=-O2 -fomit-frame-pointer
-PCDEFS=
-PCFLAGS=-fpic -pipe
-PLDFLAGS=-shared
-PLIBS=-lc
-
-include Makefile.inc
diff -ruN rexxre/Makefile.rxt rexxre-patch/Makefile.rxt
--- rexxre/Makefile.rxt	2003-05-02 07:57:10.000000000 +1200
+++ rexxre-patch/Makefile.rxt	1970-01-01 13:00:00.000000000 +1300
@@ -1,62 +0,0 @@
-# Win32 Makefile for RexxRE
-# this makefile works with the microsoft visual c compiler and rexx/trans
-# you are meant to copy Makefile.rxt to the name Makefile, and
-# then type `make dist' to get an optimised version of the library
-
-#  The contents of this file are subject to the Mozilla Public License
-#  Version 1.1 (the "License"); you may not use this file except in
-#  compliance with the License. You may obtain a copy of the License at
-#  http://www.mozilla.org/MPL/
-
-#  Software distributed under the License is distributed on an "AS IS"
-#  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
-#  License for the specific language governing rights and limitations
-#  under the License.
-
-#  The Original Code is RexxRE.
-
-#  The Initial Developer of the Original Code is Patrick TJ McPhee.
-#  Portions created by Patrick McPhee are Copyright © 2003
-#  Patrick TJ McPhee. All Rights Reserved.
-
-#  Contributors:
-
-# $Header: C:/ptjm/rexx/rexxre/RCS/Makefile.rxt 1.2 2003/05/02 12:57:09 ptjm Rel $
-
-DEBUG=-Zi
-DOPT=-Ox -G6
-INCDIR=../rexxtrans
-LIBDIR=..\rexxtrans
-CDEFS=-DREXXTRANS
-CFLAGS=$(OPT) $(DEBUG) $(CDEFS) -nologo -GF -I$(INCDIR) -Iregex -MD
-LDFLAGS=-LD $(OPT) $(DEBUG) -MD
-CC=cl
-
-PROJECT=rexxre
-
-
-OBJS=$(PROJECT).obj regcomp.obj regexec.obj regerror.obj\
- regfree.obj rxsupport.obj $(PROJECT).res
-
-$(PROJECT).dll : $(OBJS) $(PROJECT).def
-	$(CC) $(CFLAGS) $(LDFLAGS) -Fe$(PROJECT).dll $(OBJS) $(PROJECT).def $(LIBDIR)\rexxtrans.lib
-
-regcomp.obj : regex/regcomp.c
-	$(CC) -c $(CFLAGS) regex/regcomp.c
-
-regexec.obj : regex/regexec.c
-	$(CC) -c $(CFLAGS) regex/regexec.c
-
-regfree.obj : regex/regfree.c
-	$(CC) -c $(CFLAGS) regex/regfree.c
-
-regerror.obj : regex/regerror.c
-	$(CC) -c $(CFLAGS) regex/regerror.c
-
-
-dist:
-	$(MAKE) $(MAKEFLAGS) OPT="$(DOPT)" DEBUG=""
-
-
-clean:
-	del /f *.obj *.pdb *.lib *.dll *.exp *.ilk *.res
diff -ruN rexxre/Makefile.sun rexxre-patch/Makefile.sun
--- rexxre/Makefile.sun	2003-04-29 11:10:10.000000000 +1200
+++ rexxre-patch/Makefile.sun	1970-01-01 13:00:00.000000000 +1300
@@ -1,28 +0,0 @@
-# Solaris Makefile for RexxRE
-#  The contents of this file are subject to the Mozilla Public License
-#  Version 1.1 (the "License"); you may not use this file except in
-#  compliance with the License. You may obtain a copy of the License at
-#  http://www.mozilla.org/MPL/
-
-#  Software distributed under the License is distributed on an "AS IS"
-#  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
-#  License for the specific language governing rights and limitations
-#  under the License.
-
-#  The Original Code is RexxRE.
-
-#  The Initial Developer of the Original Code is Patrick TJ McPhee.
-#  Portions created by Patrick McPhee are Copyright © 1999, 2001
-#  Patrick TJ McPhee. All Rights Reserved.
-
-#  Contributors:
-
-# $Header: C:/ptjm/rexx/rexxre/RCS/Makefile.sun 1.1 2003/04/29 16:10:10 ptjm Rel $
-
-POPT=-xO2
-PCDEFS=
-PCFLAGS=-Kpic -xstrconst
-PLDFLAGS=-G
-PLIBS=
-
-include Makefile.inc
diff -ruN rexxre/README rexxre-patch/README
--- rexxre/README	2003-05-26 13:46:12.000000000 +1200
+++ rexxre-patch/README	1970-01-01 13:00:00.000000000 +1300
@@ -1,39 +0,0 @@
-RexxRE, version 1.0.1
-
-RexxRE provides a Rexx interface to POSIX regular expressions. There is
-an analog to each of the POSIX functions, and a `parse' function which
-provides functionality similar to the Rexx parse instruction.
-
-Regular expressions are strings which represent classes of strings according
-to a formal grammar. They are commonly used in free-form parsing applications.
-The POSIX regular expression grammar is provided by most operating systems as
-part of their POSIX compatibility efforts. For other systems, package includes
-a set of POSIX routines originally by Henry Spencer of the University of
-Toronto and enhanced as part of the FreeBSD project.
-
-Note that POSIX regular expressions are not compatible with the regular
-expressions provided with Object Rexx, although there are striking
-similarities. While it's unfortunate that this library does less to aid
-portability from Object Rexx's regular expression class than one might like,
-I feel that the best solution is for people to use this library with
-Object Rexx.
-
-The package includes documentation in the file rexxre.pdf and pre-built
-binaries for Regina on Win32 platforms (win32/rexxre.dll), other interpreters
-(rexxtrans/rexxre.dll), and OS/2 (os2/rexxre.dll).
-
-This is version 1.0.1. I will increment the third digit each time I do a
-bug-fix release. I will increment the second digit if I ever add a large
-number of new functions, however this is not expected. I will increment
-the first digit if I add significant new functionality, for instance
-other forms of regular expressions. I have no plans to do this.
-
-To compile the library using Microsoft C, type nmake -f Makefile.nt.
-To compile it using the MinGW version of gcc, type make -f Makefile.mingw.
-On Unix systems, look for the Makefile whose extension matches your
-system, and compile using make -f Makefile.x.
-
-See the manual for installation instructions.
-
--- Patrick TJ McPhee
-   ptjm@interlog.com
diff -ruN rexxre/csvparse.rex rexxre-patch/csvparse.rex
--- rexxre/csvparse.rex	2003-05-26 13:57:18.000000000 +1200
+++ rexxre-patch/csvparse.rex	1970-01-01 13:00:00.000000000 +1300
@@ -1,58 +0,0 @@
-/* example of parsing CSV data
- * there was some discussion of this in comp.text.tex
- *
- * csvparse..csvparse5 were used by my to debug some problems
- * encountered in the 1.0.0 release. I haven't taken the time to
- * comment them, but I've included them in the hopes that an example,
- * however cryptic, is better than nothing
- */
-
-/* trace '?'r */
-rcc = rxfuncadd('reloadfuncs', 'rexxre', 'reloadfuncs')
-if rcc then fail('load' rxfuncerrmsg())
-call reloadfuncs
-fpat = ReComp('"[^"]*"|[^,"]+', 'x')
-  somestring = 'alpha,"bravo, which has a comma and ""quotes""", charlie'
-  matched = ReParse(fpat, somestring, 'vt', 'FIELDS')
-   say fields.0 'fields'
-  do i = 1 to fields.0  
-    say fields.i
-    end
-
-fpat = ReComp(' *"[^"]*" *|[^,"]*', 'x')
-  somestring = 'alpha,"bravo, which has a comma and ""quotes""", charlie'
-  matched = ReParse(fpat, somestring, 'vt', 'FIELDS')
-   say fields.0 'fields'
-  do i = 1 to fields.0  
-    say fields.i
-    end
-
-fpat = ReComp(' *"[^"]*" *|[^,"]*', 'x')
-  somestring = ' Chemical:, "1,2-Dichlorobenzene Value","1,2-Dichlorobenzene QA Flag",,,1.2345,'
-  matched = ReParse(fpat, somestring, 'vt', 'FIELDS')
-   say fields.0 'fields'
-  do i = 1 to fields.0  
-    say i '»'fields.i'«'
-    end
-
-
-fieldre = ' *("[^"]*"|[^,"]*) *'
-  delimre = ','
-  re = fieldre
-  /* 6 is one less than the number of fields expected */
-  do 6
-    re = re || delimre || fieldre
-    end
-       
-  /* reComp that if it will be used repeatedly ... */
-  rere = reComp(re, 'x')
-
-if left(rere,1) then say 'oh, poo'
-
-say re
-
-  if reParse(rere, somestring, 'stx', 'FIELDS') then   
-    do i = 1 to fields.0
-       say i fields.i
-       end
-
diff -ruN rexxre/csvparse2.rex rexxre-patch/csvparse2.rex
--- rexxre/csvparse2.rex	2003-05-26 13:51:44.000000000 +1200
+++ rexxre-patch/csvparse2.rex	1970-01-01 13:00:00.000000000 +1300
@@ -1,27 +0,0 @@
-/* another example of parsing CSV data */
-
-/* trace '?'r */
-rcc = rxfuncadd('reloadfuncs', 'rexxre', 'reloadfuncs')
-if rcc then fail('load' rxfuncerrmsg())
-call reloadfuncs
-
-  somestring = ' Chemical:, "1,2-Dichlorobenzene Value","1,2-Dichlorobenzene QA Flag",,,1.2345,'
-
-fieldre = '("[^"]*"|[^,"]*)'
-  delimre = ' *, *'
-  re = fieldre
-  /* 6 is one less than the number of fields expected */
-  do 6
-    re = re || delimre || fieldre
-    end
-       
-  /* reComp that if it will be used repeatedly ... */
-  rere = reComp(re, 'x')
-
-if left(rere,1) then say 'oh, poo'
-
-  if reParse(rere, somestring, 'stx', 'FIELDS') then   
-    do i = 1 to fields.0
-       say i fields.i
-       end
-
diff -ruN rexxre/csvparse3.rex rexxre-patch/csvparse3.rex
--- rexxre/csvparse3.rex	2003-05-26 13:52:00.000000000 +1200
+++ rexxre-patch/csvparse3.rex	1970-01-01 13:00:00.000000000 +1300
@@ -1,35 +0,0 @@
-/* another example of parsing CSV data */
-
-/* trace '?'r */
-rcc = rxfuncadd('reloadfuncs', 'rexxre', 'reloadfuncs')
-if rcc then fail('load' rxfuncerrmsg())
-call reloadfuncs
-
-fpat = ReComp('"[^"]*"|[^,"]*', 'x')
-fdel = ReComp(' *, *')
-
-str = ' Chemical:, "1,2-Dichlorobenzene Value","1,2-Dichlorobenzene QA Flag",,,1.2345,'
-
-i = 0
-do while length(str) > 0
-  if ReParse(fpat, str, 'v', 'var', 'str') then do
-    i = i + 1
-    csv.i = var
-    /* strip the comma & spaces */
-    delim = ReParse(fdel, str, 'v', 'del', 'str')
-    end
-  else
-    leave
-  end
-
-if delim then do
-  i = i + 1
-  csv.i = ''
-  end
-
-csv.0 = i
-
-
-  do i = 1 to csv.0  
-    say i '»'csv.i'«'
-    end
diff -ruN rexxre/csvparse4.rex rexxre-patch/csvparse4.rex
--- rexxre/csvparse4.rex	2003-05-26 13:52:08.000000000 +1200
+++ rexxre-patch/csvparse4.rex	1970-01-01 13:00:00.000000000 +1300
@@ -1,30 +0,0 @@
-/* another example of parsing CSV data */
-
-/* trace '?'r */
-rcc = rxfuncadd('reloadfuncs', 'rexxre', 'reloadfuncs')
-if rcc then fail('load' rxfuncerrmsg())
-call reloadfuncs
-
-fpat = ReComp(' *"[^"]*" *|[^,"]*', 'x')
-
-str = ' Chemical:, "1,2-Dichlorobenzene Value","1,2-Dichlorobenzene QA Flag",,,1.2345,'
-
-i = 0
-do while length(str) > 0
-  if ReExec(fpat, str, 'vars', 'p') then do
-    i = i + 1
-    parse var vars.!match start len
-    csv.i = substr(str, start, start+len-1)
-    /* skip over that field */
-    str = substr(str, start+len+1)
-    end
-  else
-    leave
-  end
-
-csv.0 = i
-
-
-  do i = 1 to csv.0  
-    say i '»'csv.i'«'
-    end
diff -ruN rexxre/csvparse5.rex rexxre-patch/csvparse5.rex
--- rexxre/csvparse5.rex	2003-05-26 13:51:52.000000000 +1200
+++ rexxre-patch/csvparse5.rex	1970-01-01 13:00:00.000000000 +1300
@@ -1,14 +0,0 @@
-/* another example of parsing CSV data */
-
-/* trace '?'r */
-rcc = rxfuncadd('reloadfuncs', 'rexxre', 'reloadfuncs')
-if rcc then fail('load' rxfuncerrmsg())
-call reloadfuncs
-
-fpat = ReComp(' *"[^"]*" *|[^,"]*', 'x')
-
-str = ' Chemical:, "1,2-Dichlorobenzene Value","1,2-Dichlorobenzene QA Flag",,,1.2345,'
-
-if ReParse(fpat, str, 'vt', 'f') then do i = 1 to f.0
-  say i '«' || f.i || '»'
-  end
Binary files rexxre/os2/rexxre.dll and rexxre-patch/os2/rexxre.dll differ
diff -ruN rexxre/parsedate.rex rexxre-patch/parsedate.rex
--- rexxre/parsedate.rex	2003-04-30 15:32:14.000000000 +1200
+++ rexxre-patch/parsedate.rex	1970-01-01 13:00:00.000000000 +1300
@@ -1,117 +0,0 @@
-/* RexxRE date parsing example
- *
- * This was written to verify an example from the manual.
- * The function parsedate takes a few common free-form
- * date formats and returns the likely date in date('s')
- * format.
- *
- * Copyright 2003, Patrick TJ McPhee
- * Distributed under the Mozilla Public Licence.
- * $Header: C:/ptjm/rexx/rexxre/RCS/parsedate.rex 1.1 2003/04/30 20:32:14 ptjm Rel $
- */
-
-rcc = rxfuncadd('reloadfuncs', 'rexxre', 'reloadfuncs')
-if rcc then return 1
-call reloadfuncs
-
-say parsedate('April 30 2003')
-say parsedate('30 April 2003')
-/* this is a cheat -- the actual output of date is `Wed Apr 30 ...' */
-say parsedate('Apr 30 15:59:27 EDT 2003')
-say parsedate('30/4/2003')
-say parsedate('2003/4/30')
-say parsedate('2003/04/30')
-say parsedate('30/04/2003')
-
-exit 0
-
-parsedate: procedure
-mwre = ReComp('[[:alpha:]]+', 'x')
-mdre = ReComp('[[:digit:]]{1,2}', 'x')
-yre = ReComp('[[:digit:]]{4}', 'x')
-
-parse arg date
-
-pdate = date
-rdate = 'baddate'
-
-/* test for April 30 2003 */
-if ReParse(mwre, pdate, 'v', 'month', 'pdate') then do
-    if ReParse(mdre, pdate, 'v', 'day', 'pdate') then do
-        if ReParse(yre, pdate, 'v', 'year', 'pdate') then
-             rdate = year'/'mwords(month)'/'day
-        end
-    /* start over, trying 30 April 2003 */
-    if rdate = 'baddate' then do
-        pdate = date
-        if ReParse(mdre, pdate, 'v', 'day', 'pdate') then do
-            if ReParse(mwre, pdate, 'v', 'month', 'pdate') then do    
-                if ReParse(yre, pdate, 'v', 'year', 'pdate') then
-                     rdate = year'/'mwords(month)'/'right(day,2,'0')
-                end
-            end
-        end
-    end
-else do
-    /* test for 2003/04/30 */
-    pdate = date
-    if ReParse(yre, pdate, 'v', 'year', 'pdate') then do
-        if ReParse(mdre, pdate, 'v', 'month', 'pdate') then do    
-            if ReParse(mdre, pdate, 'v', 'day', 'pdate') then
-                rdate = year'/'right(month,2,'0')'/'right(day,2,'0')
-            end
-        end
-
-    /* test for 30/04/2003, then give up */
-    if rdate = 'baddate' then do
-        pdate = date
-        if ReParse(mdre, pdate, 'v', 'day', 'pdate') then do
-            if ReParse(mdre, pdate, 'v', 'month', 'pdate') then do    
-                if ReParse(yre, pdate, 'v', 'year', 'pdate') then
-                    rdate = year'/'right(month,2,'0')'/'right(day,2,'0')
-                end
-            end
-        end
-    end
-
-call ReFree mwre, yre, mdre
-return rdate
-
-mwords: procedure
-  mw.january = '01'
-  mw.february = '02'
-  mw.march = '03'
-  mw.april = '04'
-  mw.may = '05'
-  mw.june = '06'
-  mw.july = '07'
-  mw.august = '08'
-  mw.september = '09'
-  mw.october = '10'
-  mw.november = '11'
-  mw.december = '12'
-  mw.jan = '01'
-  mw.feb = '02'
-  mw.mar = '03'
-  mw.apr = '04'
-  mw.may = '05'
-  mw.jun = '06'
-  mw.jul = '07'
-  mw.aug = '08'
-  mw.sep = '09'
-  mw.oct = '10'
-  mw.nov = '11'
-  mw.dec = '12'
-  mw.janvier = '01'
-  mw.fevrier = '02'
-  mw.fev = '02'
-  mw.mars = '03'
-  mw.avril = '04'
-  mw.avr = '04'
-  mw.mai = '05'
-  mw.juillet = '07'
-  mw.aout = '08'
-  mw.aou = '08'
-
-  arg mon
-  return mw.mon
diff -ruN rexxre/regex/cclass.h rexxre-patch/regex/cclass.h
--- rexxre/regex/cclass.h	2002-03-22 18:41:56.000000000 +1300
+++ rexxre-patch/regex/cclass.h	1970-01-01 13:00:00.000000000 +1300
@@ -1,63 +0,0 @@
-/*-
- * Copyright (c) 1992, 1993, 1994 Henry Spencer.
- * Copyright (c) 1992, 1993, 1994
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Henry Spencer.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)cclass.h	8.3 (Berkeley) 3/20/94
- * $FreeBSD$
- */
-
-
-typedef enum {CALNUM, CALPHA, CBLANK, CCNTRL, CDIGIT, CGRAPH,
-	      CLOWER, CPRINT, CPUNCT, CSPACE, CUPPER, CXDIGIT} citype;
-
-/* character-class table */
-static struct cclass {
-	char *name;
-	citype fidx;
-} cclasses[] = {
-	{"alnum",       CALNUM},
-	{"alpha",       CALPHA},
-	{"blank",       CBLANK},
-	{"cntrl",       CCNTRL},
-	{"digit",       CDIGIT},
-	{"graph",       CGRAPH},
-	{"lower",       CLOWER},
-	{"print",       CPRINT},
-	{"punct",       CPUNCT},
-	{"space",       CSPACE},
-	{"upper",       CUPPER},
-	{"xdigit",      CXDIGIT},
-	{NULL,          }
-};
diff -ruN rexxre/regex/cname.h rexxre-patch/regex/cname.h
--- rexxre/regex/cname.h	2002-03-22 18:41:56.000000000 +1300
+++ rexxre-patch/regex/cname.h	1970-01-01 13:00:00.000000000 +1300
@@ -1,142 +0,0 @@
-/*-
- * Copyright (c) 1992, 1993, 1994 Henry Spencer.
- * Copyright (c) 1992, 1993, 1994
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Henry Spencer.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)cname.h	8.3 (Berkeley) 3/20/94
- * $FreeBSD$
- */
-
-/* character-name table */
-static struct cname {
-	char *name;
-	char code;
-} cnames[] = {
-	{"NUL",			'\0'},
-	{"SOH",			'\001'},
-	{"STX",			'\002'},
-	{"ETX",			'\003'},
-	{"EOT",			'\004'},
-	{"ENQ",			'\005'},
-	{"ACK",			'\006'},
-	{"BEL",			'\007'},
-	{"alert",		'\007'},
-	{"BS",			'\010'},
-	{"backspace",		'\b'},
-	{"HT",			'\011'},
-	{"tab",			'\t'},
-	{"LF",			'\012'},
-	{"newline",		'\n'},
-	{"VT",			'\013'},
-	{"vertical-tab",	'\v'},
-	{"FF",			'\014'},
-	{"form-feed",		'\f'},
-	{"CR",			'\015'},
-	{"carriage-return",	'\r'},
-	{"SO",			'\016'},
-	{"SI",			'\017'},
-	{"DLE",			'\020'},
-	{"DC1",			'\021'},
-	{"DC2",			'\022'},
-	{"DC3",			'\023'},
-	{"DC4",			'\024'},
-	{"NAK",			'\025'},
-	{"SYN",			'\026'},
-	{"ETB",			'\027'},
-	{"CAN",			'\030'},
-	{"EM",			'\031'},
-	{"SUB",			'\032'},
-	{"ESC",			'\033'},
-	{"IS4",			'\034'},
-	{"FS",			'\034'},
-	{"IS3",			'\035'},
-	{"GS",			'\035'},
-	{"IS2",			'\036'},
-	{"RS",			'\036'},
-	{"IS1",			'\037'},
-	{"US",			'\037'},
-	{"space",		' '},
-	{"exclamation-mark",	'!'},
-	{"quotation-mark",	'"'},
-	{"number-sign",		'#'},
-	{"dollar-sign",		'$'},
-	{"percent-sign",	'%'},
-	{"ampersand",		'&'},
-	{"apostrophe",		'\''},
-	{"left-parenthesis",	'('},
-	{"right-parenthesis",	')'},
-	{"asterisk",		'*'},
-	{"plus-sign",		'+'},
-	{"comma",		','},
-	{"hyphen",		'-'},
-	{"hyphen-minus",	'-'},
-	{"period",		'.'},
-	{"full-stop",		'.'},
-	{"slash",		'/'},
-	{"solidus",		'/'},
-	{"zero",		'0'},
-	{"one",			'1'},
-	{"two",			'2'},
-	{"three",		'3'},
-	{"four",		'4'},
-	{"five",		'5'},
-	{"six",			'6'},
-	{"seven",      		'7'},
-	{"eight",		'8'},
-	{"nine",		'9'},
-	{"colon",		':'},
-	{"semicolon",		';'},
-	{"less-than-sign",	'<'},
-	{"equals-sign",		'='},
-	{"greater-than-sign",	'>'},
-	{"question-mark",	'?'},
-	{"commercial-at",	'@'},
-	{"left-square-bracket",	'['},
-	{"backslash",		'\\'},
-	{"reverse-solidus",	'\\'},
-	{"right-square-bracket",']'},
-	{"circumflex",		'^'},
-	{"circumflex-accent",	'^'},
-	{"underscore",		'_'},
-	{"low-line",		'_'},
-	{"grave-accent",	'`'},
-	{"left-brace",		'{'},
-	{"left-curly-bracket",	'{'},
-	{"vertical-line",	'|'},
-	{"right-brace",		'}'},
-	{"right-curly-bracket",	'}'},
-	{"tilde",		'~'},
-	{"DEL",	'\177'},
-	{NULL,	0}
-};
diff -ruN rexxre/regex/collate.h rexxre-patch/regex/collate.h
--- rexxre/regex/collate.h	2003-04-29 09:52:26.000000000 +1200
+++ rexxre-patch/regex/collate.h	1970-01-01 13:00:00.000000000 +1300
@@ -1,14 +0,0 @@
-/*-
- * Hacked up substitute for collate.h, which is a hook into the FreeBSD
- * internationalisation code. This means things like [:upper:] won't work
- * correctly, but I need to rewrite the internationalisation code for REs
- * for that to work in any case.
- */
-
-#ifndef _COLLATE_H_
-#define	_COLLATE_H_
-
-#define __collate_load_error 0
-#define	__collate_range_cmp(x, y) ((int)x - (int)y)
-
-#endif /* !_COLLATE_H_ */
diff -ruN rexxre/regex/engine.c rexxre-patch/regex/engine.c
--- rexxre/regex/engine.c	2002-03-22 16:52:48.000000000 +1300
+++ rexxre-patch/regex/engine.c	1970-01-01 13:00:00.000000000 +1300
@@ -1,1140 +0,0 @@
-/*-
- * Copyright (c) 1992, 1993, 1994 Henry Spencer.
- * Copyright (c) 1992, 1993, 1994
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Henry Spencer.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)engine.c	8.5 (Berkeley) 3/20/94
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD$");
-
-/*
- * The matching engine and friends.  This file is #included by regexec.c
- * after suitable #defines of a variety of macros used herein, so that
- * different state representations can be used without duplicating masses
- * of code.
- */
-
-#ifdef SNAMES
-#define	matcher	smatcher
-#define	fast	sfast
-#define	slow	sslow
-#define	dissect	sdissect
-#define	backref	sbackref
-#define	step	sstep
-#define	print	sprint
-#define	at	sat
-#define	match	smat
-#endif
-#ifdef LNAMES
-#define	matcher	lmatcher
-#define	fast	lfast
-#define	slow	lslow
-#define	dissect	ldissect
-#define	backref	lbackref
-#define	step	lstep
-#define	print	lprint
-#define	at	lat
-#define	match	lmat
-#endif
-
-/* another structure passed up and down to avoid zillions of parameters */
-struct match {
-	struct re_guts *g;
-	int eflags;
-	regmatch_t *pmatch;	/* [nsub+1] (0 element unused) */
-	char *offp;		/* offsets work from here */
-	char *beginp;		/* start of string -- virtual NUL precedes */
-	char *endp;		/* end of string -- virtual NUL here */
-	char *coldp;		/* can be no match starting before here */
-	char **lastpos;		/* [nplus+1] */
-	STATEVARS;
-	states st;		/* current states */
-	states fresh;		/* states for a fresh start */
-	states tmp;		/* temporary */
-	states empty;		/* empty set of states */
-};
-
-/* ========= begin header generated by ./mkh ========= */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* === engine.c === */
-static int matcher(struct re_guts *g, char *string, size_t nmatch, regmatch_t pmatch[], int eflags);
-static char *dissect(struct match *m, char *start, char *stop, sopno startst, sopno stopst);
-static char *backref(struct match *m, char *start, char *stop, sopno startst, sopno stopst, sopno lev);
-static char *fast(struct match *m, char *start, char *stop, sopno startst, sopno stopst);
-static char *slow(struct match *m, char *start, char *stop, sopno startst, sopno stopst);
-static states step(struct re_guts *g, sopno start, sopno stop, states bef, int ch, states aft);
-#define	BOL	(OUT+1)
-#define	EOL	(BOL+1)
-#define	BOLEOL	(BOL+2)
-#define	NOTHING	(BOL+3)
-#define	BOW	(BOL+4)
-#define	EOW	(BOL+5)
-#define	CODEMAX	(BOL+5)		/* highest code used */
-#define	NONCHAR(c)	((c) > CHAR_MAX)
-#define	NNONCHAR	(CODEMAX-CHAR_MAX)
-#ifdef REDEBUG
-static void print(struct match *m, char *caption, states st, int ch, FILE *d);
-#endif
-#ifdef REDEBUG
-static void at(struct match *m, char *title, char *start, char *stop, sopno startst, sopno stopst);
-#endif
-#ifdef REDEBUG
-static char *pchar(int ch);
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-/* ========= end header generated by ./mkh ========= */
-
-#ifdef REDEBUG
-#define	SP(t, s, c)	print(m, t, s, c, stdout)
-#define	AT(t, p1, p2, s1, s2)	at(m, t, p1, p2, s1, s2)
-#define	NOTE(str)	{ if (m->eflags&REG_TRACE) printf("=%s\n", (str)); }
-#else
-#define	SP(t, s, c)	/* nothing */
-#define	AT(t, p1, p2, s1, s2)	/* nothing */
-#define	NOTE(s)	/* nothing */
-#endif
-
-/*
- - matcher - the actual matching engine
- == static int matcher(struct re_guts *g, char *string, \
- ==	size_t nmatch, regmatch_t pmatch[], int eflags);
- */
-static int			/* 0 success, REG_NOMATCH failure */
-matcher(g, string, nmatch, pmatch, eflags)
-struct re_guts *g;
-char *string;
-size_t nmatch;
-regmatch_t pmatch[];
-int eflags;
-{
-	char *endp;
-	int i;
-	struct match mv;
-	struct match *m = &mv;
-	char *dp;
-	const sopno gf = g->firststate+1;	/* +1 for OEND */
-	const sopno gl = g->laststate;
-	char *start;
-	char *stop;
-	/* Boyer-Moore algorithms variables */
-	char *pp;
-	int cj, mj;
-	char *mustfirst;
-	char *mustlast;
-	int *matchjump;
-	int *charjump;
-
-	/* simplify the situation where possible */
-	if (g->cflags&REG_NOSUB)
-		nmatch = 0;
-	if (eflags&REG_STARTEND) {
-		start = string + pmatch[0].rm_so;
-		stop = string + pmatch[0].rm_eo;
-	} else {
-		start = string;
-		stop = start + strlen(start);
-	}
-	if (stop < start)
-		return(REG_INVARG);
-
-	/* prescreening; this does wonders for this rather slow code */
-	if (g->must != NULL) {
-		if (g->charjump != NULL && g->matchjump != NULL) {
-			mustfirst = g->must;
-			mustlast = g->must + g->mlen - 1;
-			charjump = g->charjump;
-			matchjump = g->matchjump;
-			pp = mustlast;
-			for (dp = start+g->mlen-1; dp < stop;) {
-				/* Fast skip non-matches */
-				while (dp < stop && charjump[*dp])
-					dp += charjump[*dp];
-
-				if (dp >= stop)
-					break;
-
-				/* Greedy matcher */
-				/* We depend on not being used for
-				 * for strings of length 1
-				 */
-				while (*--dp == *--pp && pp != mustfirst);
-
-				if (*dp == *pp)
-					break;
-
-				/* Jump to next possible match */
-				mj = matchjump[pp - mustfirst];
-				cj = charjump[*dp];
-				dp += (cj < mj ? mj : cj);
-				pp = mustlast;
-			}
-			if (pp != mustfirst)
-				return(REG_NOMATCH);
-		} else {
-			for (dp = start; dp < stop; dp++)
-				if (*dp == g->must[0] &&
-				    stop - dp >= g->mlen &&
-				    memcmp(dp, g->must, (size_t)g->mlen) == 0)
-					break;
-			if (dp == stop)		/* we didn't find g->must */
-				return(REG_NOMATCH);
-		}
-	}
-
-	/* match struct setup */
-	m->g = g;
-	m->eflags = eflags;
-	m->pmatch = NULL;
-	m->lastpos = NULL;
-	m->offp = string;
-	m->beginp = start;
-	m->endp = stop;
-	STATESETUP(m, 4);
-	SETUP(m->st);
-	SETUP(m->fresh);
-	SETUP(m->tmp);
-	SETUP(m->empty);
-	CLEAR(m->empty);
-
-	/* Adjust start according to moffset, to speed things up */
-	if (g->moffset > -1)
-		start = ((dp - g->moffset) < start) ? start : dp - g->moffset;
-
-	/* this loop does only one repetition except for backrefs */
-	for (;;) {
-		endp = fast(m, start, stop, gf, gl);
-		if (endp == NULL) {		/* a miss */
-			STATETEARDOWN(m);
-			return(REG_NOMATCH);
-		}
-		if (nmatch == 0 && !g->backrefs)
-			break;		/* no further info needed */
-
-		/* where? */
-		assert(m->coldp != NULL);
-		for (;;) {
-			NOTE("finding start");
-			endp = slow(m, m->coldp, stop, gf, gl);
-			if (endp != NULL)
-				break;
-			assert(m->coldp < m->endp);
-			m->coldp++;
-		}
-		if (nmatch == 1 && !g->backrefs)
-			break;		/* no further info needed */
-
-		/* oh my, he wants the subexpressions... */
-		if (m->pmatch == NULL)
-			m->pmatch = (regmatch_t *)malloc((m->g->nsub + 1) *
-							sizeof(regmatch_t));
-		if (m->pmatch == NULL) {
-			STATETEARDOWN(m);
-			return(REG_ESPACE);
-		}
-		for (i = 1; i <= m->g->nsub; i++)
-			m->pmatch[i].rm_so = m->pmatch[i].rm_eo = -1;
-		if (!g->backrefs && !(m->eflags&REG_BACKR)) {
-			NOTE("dissecting");
-			dp = dissect(m, m->coldp, endp, gf, gl);
-		} else {
-			if (g->nplus > 0 && m->lastpos == NULL)
-				m->lastpos = (char **)malloc((g->nplus+1) *
-							sizeof(char *));
-			if (g->nplus > 0 && m->lastpos == NULL) {
-				free(m->pmatch);
-				STATETEARDOWN(m);
-				return(REG_ESPACE);
-			}
-			NOTE("backref dissect");
-			dp = backref(m, m->coldp, endp, gf, gl, (sopno)0);
-		}
-		if (dp != NULL)
-			break;
-
-		/* uh-oh... we couldn't find a subexpression-level match */
-		assert(g->backrefs);	/* must be back references doing it */
-		assert(g->nplus == 0 || m->lastpos != NULL);
-		for (;;) {
-			if (dp != NULL || endp <= m->coldp)
-				break;		/* defeat */
-			NOTE("backoff");
-			endp = slow(m, m->coldp, endp-1, gf, gl);
-			if (endp == NULL)
-				break;		/* defeat */
-			/* try it on a shorter possibility */
-#ifndef NDEBUG
-			for (i = 1; i <= m->g->nsub; i++) {
-				assert(m->pmatch[i].rm_so == -1);
-				assert(m->pmatch[i].rm_eo == -1);
-			}
-#endif
-			NOTE("backoff dissect");
-			dp = backref(m, m->coldp, endp, gf, gl, (sopno)0);
-		}
-		assert(dp == NULL || dp == endp);
-		if (dp != NULL)		/* found a shorter one */
-			break;
-
-		/* despite initial appearances, there is no match here */
-		NOTE("false alarm");
-		start = m->coldp + 1;	/* recycle starting later */
-		assert(start <= stop);
-	}
-
-	/* fill in the details if requested */
-	if (nmatch > 0) {
-		pmatch[0].rm_so = m->coldp - m->offp;
-		pmatch[0].rm_eo = endp - m->offp;
-	}
-	if (nmatch > 1) {
-		assert(m->pmatch != NULL);
-		for (i = 1; i < nmatch; i++)
-			if (i <= m->g->nsub)
-				pmatch[i] = m->pmatch[i];
-			else {
-				pmatch[i].rm_so = -1;
-				pmatch[i].rm_eo = -1;
-			}
-	}
-
-	if (m->pmatch != NULL)
-		free((char *)m->pmatch);
-	if (m->lastpos != NULL)
-		free((char *)m->lastpos);
-	STATETEARDOWN(m);
-	return(0);
-}
-
-/*
- - dissect - figure out what matched what, no back references
- == static char *dissect(struct match *m, char *start, \
- ==	char *stop, sopno startst, sopno stopst);
- */
-static char *			/* == stop (success) always */
-dissect(m, start, stop, startst, stopst)
-struct match *m;
-char *start;
-char *stop;
-sopno startst;
-sopno stopst;
-{
-	int i;
-	sopno ss;		/* start sop of current subRE */
-	sopno es;		/* end sop of current subRE */
-	char *sp;		/* start of string matched by it */
-	char *stp;		/* string matched by it cannot pass here */
-	char *rest;		/* start of rest of string */
-	char *tail;		/* string unmatched by rest of RE */
-	sopno ssub;		/* start sop of subsubRE */
-	sopno esub;		/* end sop of subsubRE */
-	char *ssp;		/* start of string matched by subsubRE */
-	char *sep;		/* end of string matched by subsubRE */
-	char *oldssp;		/* previous ssp */
-	char *dp;
-
-	AT("diss", start, stop, startst, stopst);
-	sp = start;
-	for (ss = startst; ss < stopst; ss = es) {
-		/* identify end of subRE */
-		es = ss;
-		switch (OP(m->g->strip[es])) {
-		case OPLUS_:
-		case OQUEST_:
-			es += OPND(m->g->strip[es]);
-			break;
-		case OCH_:
-			while (OP(m->g->strip[es]) != O_CH)
-				es += OPND(m->g->strip[es]);
-			break;
-		}
-		es++;
-
-		/* figure out what it matched */
-		switch (OP(m->g->strip[ss])) {
-		case OEND:
-			assert(nope);
-			break;
-		case OCHAR:
-			sp++;
-			break;
-		case OBOL:
-		case OEOL:
-		case OBOW:
-		case OEOW:
-			break;
-		case OANY:
-		case OANYOF:
-			sp++;
-			break;
-		case OBACK_:
-		case O_BACK:
-			assert(nope);
-			break;
-		/* cases where length of match is hard to find */
-		case OQUEST_:
-			stp = stop;
-			for (;;) {
-				/* how long could this one be? */
-				rest = slow(m, sp, stp, ss, es);
-				assert(rest != NULL);	/* it did match */
-				/* could the rest match the rest? */
-				tail = slow(m, rest, stop, es, stopst);
-				if (tail == stop)
-					break;		/* yes! */
-				/* no -- try a shorter match for this one */
-				stp = rest - 1;
-				assert(stp >= sp);	/* it did work */
-			}
-			ssub = ss + 1;
-			esub = es - 1;
-			/* did innards match? */
-			if (slow(m, sp, rest, ssub, esub) != NULL) {
-				dp = dissect(m, sp, rest, ssub, esub);
-				assert(dp == rest);
-			} else		/* no */
-				assert(sp == rest);
-			sp = rest;
-			break;
-		case OPLUS_:
-			stp = stop;
-			for (;;) {
-				/* how long could this one be? */
-				rest = slow(m, sp, stp, ss, es);
-				assert(rest != NULL);	/* it did match */
-				/* could the rest match the rest? */
-				tail = slow(m, rest, stop, es, stopst);
-				if (tail == stop)
-					break;		/* yes! */
-				/* no -- try a shorter match for this one */
-				stp = rest - 1;
-				assert(stp >= sp);	/* it did work */
-			}
-			ssub = ss + 1;
-			esub = es - 1;
-			ssp = sp;
-			oldssp = ssp;
-			for (;;) {	/* find last match of innards */
-				sep = slow(m, ssp, rest, ssub, esub);
-				if (sep == NULL || sep == ssp)
-					break;	/* failed or matched null */
-				oldssp = ssp;	/* on to next try */
-				ssp = sep;
-			}
-			if (sep == NULL) {
-				/* last successful match */
-				sep = ssp;
-				ssp = oldssp;
-			}
-			assert(sep == rest);	/* must exhaust substring */
-			assert(slow(m, ssp, sep, ssub, esub) == rest);
-			dp = dissect(m, ssp, sep, ssub, esub);
-			assert(dp == sep);
-			sp = rest;
-			break;
-		case OCH_:
-			stp = stop;
-			for (;;) {
-				/* how long could this one be? */
-				rest = slow(m, sp, stp, ss, es);
-				assert(rest != NULL);	/* it did match */
-				/* could the rest match the rest? */
-				tail = slow(m, rest, stop, es, stopst);
-				if (tail == stop)
-					break;		/* yes! */
-				/* no -- try a shorter match for this one */
-				stp = rest - 1;
-				assert(stp >= sp);	/* it did work */
-			}
-			ssub = ss + 1;
-			esub = ss + OPND(m->g->strip[ss]) - 1;
-			assert(OP(m->g->strip[esub]) == OOR1);
-			for (;;) {	/* find first matching branch */
-				if (slow(m, sp, rest, ssub, esub) == rest)
-					break;	/* it matched all of it */
-				/* that one missed, try next one */
-				assert(OP(m->g->strip[esub]) == OOR1);
-				esub++;
-				assert(OP(m->g->strip[esub]) == OOR2);
-				ssub = esub + 1;
-				esub += OPND(m->g->strip[esub]);
-				if (OP(m->g->strip[esub]) == OOR2)
-					esub--;
-				else
-					assert(OP(m->g->strip[esub]) == O_CH);
-			}
-			dp = dissect(m, sp, rest, ssub, esub);
-			assert(dp == rest);
-			sp = rest;
-			break;
-		case O_PLUS:
-		case O_QUEST:
-		case OOR1:
-		case OOR2:
-		case O_CH:
-			assert(nope);
-			break;
-		case OLPAREN:
-			i = OPND(m->g->strip[ss]);
-			assert(0 < i && i <= m->g->nsub);
-			m->pmatch[i].rm_so = sp - m->offp;
-			break;
-		case ORPAREN:
-			i = OPND(m->g->strip[ss]);
-			assert(0 < i && i <= m->g->nsub);
-			m->pmatch[i].rm_eo = sp - m->offp;
-			break;
-		default:		/* uh oh */
-			assert(nope);
-			break;
-		}
-	}
-
-	assert(sp == stop);
-	return(sp);
-}
-
-/*
- - backref - figure out what matched what, figuring in back references
- == static char *backref(struct match *m, char *start, \
- ==	char *stop, sopno startst, sopno stopst, sopno lev);
- */
-static char *			/* == stop (success) or NULL (failure) */
-backref(m, start, stop, startst, stopst, lev)
-struct match *m;
-char *start;
-char *stop;
-sopno startst;
-sopno stopst;
-sopno lev;			/* PLUS nesting level */
-{
-	int i;
-	sopno ss;		/* start sop of current subRE */
-	char *sp;		/* start of string matched by it */
-	sopno ssub;		/* start sop of subsubRE */
-	sopno esub;		/* end sop of subsubRE */
-	char *ssp;		/* start of string matched by subsubRE */
-	char *dp;
-	size_t len;
-	int hard;
-	sop s;
-	regoff_t offsave;
-	cset *cs;
-
-	AT("back", start, stop, startst, stopst);
-	sp = start;
-
-	/* get as far as we can with easy stuff */
-	hard = 0;
-	for (ss = startst; !hard && ss < stopst; ss++)
-		switch (OP(s = m->g->strip[ss])) {
-		case OCHAR:
-			if (sp == stop || *sp++ != (char)OPND(s))
-				return(NULL);
-			break;
-		case OANY:
-			if (sp == stop)
-				return(NULL);
-			sp++;
-			break;
-		case OANYOF:
-			cs = &m->g->sets[OPND(s)];
-			if (sp == stop || !CHIN(cs, *sp++))
-				return(NULL);
-			break;
-		case OBOL:
-			if ( (sp == m->beginp && !(m->eflags&REG_NOTBOL)) ||
-					(sp < m->endp && *(sp-1) == '\n' &&
-						(m->g->cflags&REG_NEWLINE)) )
-				{ /* yes */ }
-			else
-				return(NULL);
-			break;
-		case OEOL:
-			if ( (sp == m->endp && !(m->eflags&REG_NOTEOL)) ||
-					(sp < m->endp && *sp == '\n' &&
-						(m->g->cflags&REG_NEWLINE)) )
-				{ /* yes */ }
-			else
-				return(NULL);
-			break;
-		case OBOW:
-			if (( (sp == m->beginp && !(m->eflags&REG_NOTBOL)) ||
-					(sp < m->endp && *(sp-1) == '\n' &&
-						(m->g->cflags&REG_NEWLINE)) ||
-					(sp > m->beginp &&
-							!ISWORD(*(sp-1))) ) &&
-					(sp < m->endp && ISWORD(*sp)) )
-				{ /* yes */ }
-			else
-				return(NULL);
-			break;
-		case OEOW:
-			if (( (sp == m->endp && !(m->eflags&REG_NOTEOL)) ||
-					(sp < m->endp && *sp == '\n' &&
-						(m->g->cflags&REG_NEWLINE)) ||
-					(sp < m->endp && !ISWORD(*sp)) ) &&
-					(sp > m->beginp && ISWORD(*(sp-1))) )
-				{ /* yes */ }
-			else
-				return(NULL);
-			break;
-		case O_QUEST:
-			break;
-		case OOR1:	/* matches null but needs to skip */
-			ss++;
-			s = m->g->strip[ss];
-			do {
-				assert(OP(s) == OOR2);
-				ss += OPND(s);
-			} while (OP(s = m->g->strip[ss]) != O_CH);
-			/* note that the ss++ gets us past the O_CH */
-			break;
-		default:	/* have to make a choice */
-			hard = 1;
-			break;
-		}
-	if (!hard) {		/* that was it! */
-		if (sp != stop)
-			return(NULL);
-		return(sp);
-	}
-	ss--;			/* adjust for the for's final increment */
-
-	/* the hard stuff */
-	AT("hard", sp, stop, ss, stopst);
-	s = m->g->strip[ss];
-	switch (OP(s)) {
-	case OBACK_:		/* the vilest depths */
-		i = OPND(s);
-		assert(0 < i && i <= m->g->nsub);
-		if (m->pmatch[i].rm_eo == -1)
-			return(NULL);
-		assert(m->pmatch[i].rm_so != -1);
-		len = m->pmatch[i].rm_eo - m->pmatch[i].rm_so;
-		assert(stop - m->beginp >= len);
-		if (sp > stop - len)
-			return(NULL);	/* not enough left to match */
-		ssp = m->offp + m->pmatch[i].rm_so;
-		if (memcmp(sp, ssp, len) != 0)
-			return(NULL);
-		while (m->g->strip[ss] != SOP(O_BACK, i))
-			ss++;
-		return(backref(m, sp+len, stop, ss+1, stopst, lev));
-		break;
-	case OQUEST_:		/* to null or not */
-		dp = backref(m, sp, stop, ss+1, stopst, lev);
-		if (dp != NULL)
-			return(dp);	/* not */
-		return(backref(m, sp, stop, ss+OPND(s)+1, stopst, lev));
-		break;
-	case OPLUS_:
-		assert(m->lastpos != NULL);
-		assert(lev+1 <= m->g->nplus);
-		m->lastpos[lev+1] = sp;
-		return(backref(m, sp, stop, ss+1, stopst, lev+1));
-		break;
-	case O_PLUS:
-		if (sp == m->lastpos[lev])	/* last pass matched null */
-			return(backref(m, sp, stop, ss+1, stopst, lev-1));
-		/* try another pass */
-		m->lastpos[lev] = sp;
-		dp = backref(m, sp, stop, ss-OPND(s)+1, stopst, lev);
-		if (dp == NULL)
-			return(backref(m, sp, stop, ss+1, stopst, lev-1));
-		else
-			return(dp);
-		break;
-	case OCH_:		/* find the right one, if any */
-		ssub = ss + 1;
-		esub = ss + OPND(s) - 1;
-		assert(OP(m->g->strip[esub]) == OOR1);
-		for (;;) {	/* find first matching branch */
-			dp = backref(m, sp, stop, ssub, esub, lev);
-			if (dp != NULL)
-				return(dp);
-			/* that one missed, try next one */
-			if (OP(m->g->strip[esub]) == O_CH)
-				return(NULL);	/* there is none */
-			esub++;
-			assert(OP(m->g->strip[esub]) == OOR2);
-			ssub = esub + 1;
-			esub += OPND(m->g->strip[esub]);
-			if (OP(m->g->strip[esub]) == OOR2)
-				esub--;
-			else
-				assert(OP(m->g->strip[esub]) == O_CH);
-		}
-		break;
-	case OLPAREN:		/* must undo assignment if rest fails */
-		i = OPND(s);
-		assert(0 < i && i <= m->g->nsub);
-		offsave = m->pmatch[i].rm_so;
-		m->pmatch[i].rm_so = sp - m->offp;
-		dp = backref(m, sp, stop, ss+1, stopst, lev);
-		if (dp != NULL)
-			return(dp);
-		m->pmatch[i].rm_so = offsave;
-		return(NULL);
-		break;
-	case ORPAREN:		/* must undo assignment if rest fails */
-		i = OPND(s);
-		assert(0 < i && i <= m->g->nsub);
-		offsave = m->pmatch[i].rm_eo;
-		m->pmatch[i].rm_eo = sp - m->offp;
-		dp = backref(m, sp, stop, ss+1, stopst, lev);
-		if (dp != NULL)
-			return(dp);
-		m->pmatch[i].rm_eo = offsave;
-		return(NULL);
-		break;
-	default:		/* uh oh */
-		assert(nope);
-		break;
-	}
-
-	/* "can't happen" */
-	assert(nope);
-	/* NOTREACHED */
-	return "shut up gcc";
-}
-
-/*
- - fast - step through the string at top speed
- == static char *fast(struct match *m, char *start, \
- ==	char *stop, sopno startst, sopno stopst);
- */
-static char *			/* where tentative match ended, or NULL */
-fast(m, start, stop, startst, stopst)
-struct match *m;
-char *start;
-char *stop;
-sopno startst;
-sopno stopst;
-{
-	states st = m->st;
-	states fresh = m->fresh;
-	states tmp = m->tmp;
-	char *p = start;
-	int c = (start == m->beginp) ? OUT : *(start-1);
-	int lastc;		/* previous c */
-	int flagch;
-	int i;
-	char *coldp;		/* last p after which no match was underway */
-
-	CLEAR(st);
-	SET1(st, startst);
-	st = step(m->g, startst, stopst, st, NOTHING, st);
-	ASSIGN(fresh, st);
-	SP("start", st, *p);
-	coldp = NULL;
-	for (;;) {
-		/* next character */
-		lastc = c;
-		c = (p == m->endp) ? OUT : *p;
-		if (EQ(st, fresh))
-			coldp = p;
-
-		/* is there an EOL and/or BOL between lastc and c? */
-		flagch = '\0';
-		i = 0;
-		if ( (lastc == '\n' && m->g->cflags&REG_NEWLINE) ||
-				(lastc == OUT && !(m->eflags&REG_NOTBOL)) ) {
-			flagch = BOL;
-			i = m->g->nbol;
-		}
-		if ( (c == '\n' && m->g->cflags&REG_NEWLINE) ||
-				(c == OUT && !(m->eflags&REG_NOTEOL)) ) {
-			flagch = (flagch == BOL) ? BOLEOL : EOL;
-			i += m->g->neol;
-		}
-		if (i != 0) {
-			for (; i > 0; i--)
-				st = step(m->g, startst, stopst, st, flagch, st);
-			SP("boleol", st, c);
-		}
-
-		/* how about a word boundary? */
-		if ( (flagch == BOL || (lastc != OUT && !ISWORD(lastc))) &&
-					(c != OUT && ISWORD(c)) ) {
-			flagch = BOW;
-		}
-		if ( (lastc != OUT && ISWORD(lastc)) &&
-				(flagch == EOL || (c != OUT && !ISWORD(c))) ) {
-			flagch = EOW;
-		}
-		if (flagch == BOW || flagch == EOW) {
-			st = step(m->g, startst, stopst, st, flagch, st);
-			SP("boweow", st, c);
-		}
-
-		/* are we done? */
-		if (ISSET(st, stopst) || p == stop)
-			break;		/* NOTE BREAK OUT */
-
-		/* no, we must deal with this character */
-		ASSIGN(tmp, st);
-		ASSIGN(st, fresh);
-		assert(c != OUT);
-		st = step(m->g, startst, stopst, tmp, c, st);
-		SP("aft", st, c);
-		assert(EQ(step(m->g, startst, stopst, st, NOTHING, st), st));
-		p++;
-	}
-
-	assert(coldp != NULL);
-	m->coldp = coldp;
-	if (ISSET(st, stopst))
-		return(p+1);
-	else
-		return(NULL);
-}
-
-/*
- - slow - step through the string more deliberately
- == static char *slow(struct match *m, char *start, \
- ==	char *stop, sopno startst, sopno stopst);
- */
-static char *			/* where it ended */
-slow(m, start, stop, startst, stopst)
-struct match *m;
-char *start;
-char *stop;
-sopno startst;
-sopno stopst;
-{
-	states st = m->st;
-	states empty = m->empty;
-	states tmp = m->tmp;
-	char *p = start;
-	int c = (start == m->beginp) ? OUT : *(start-1);
-	int lastc;		/* previous c */
-	int flagch;
-	int i;
-	char *matchp;		/* last p at which a match ended */
-
-	AT("slow", start, stop, startst, stopst);
-	CLEAR(st);
-	SET1(st, startst);
-	SP("sstart", st, *p);
-	st = step(m->g, startst, stopst, st, NOTHING, st);
-	matchp = NULL;
-	for (;;) {
-		/* next character */
-		lastc = c;
-		c = (p == m->endp) ? OUT : *p;
-
-		/* is there an EOL and/or BOL between lastc and c? */
-		flagch = '\0';
-		i = 0;
-		if ( (lastc == '\n' && m->g->cflags&REG_NEWLINE) ||
-				(lastc == OUT && !(m->eflags&REG_NOTBOL)) ) {
-			flagch = BOL;
-			i = m->g->nbol;
-		}
-		if ( (c == '\n' && m->g->cflags&REG_NEWLINE) ||
-				(c == OUT && !(m->eflags&REG_NOTEOL)) ) {
-			flagch = (flagch == BOL) ? BOLEOL : EOL;
-			i += m->g->neol;
-		}
-		if (i != 0) {
-			for (; i > 0; i--)
-				st = step(m->g, startst, stopst, st, flagch, st);
-			SP("sboleol", st, c);
-		}
-
-		/* how about a word boundary? */
-		if ( (flagch == BOL || (lastc != OUT && !ISWORD(lastc))) &&
-					(c != OUT && ISWORD(c)) ) {
-			flagch = BOW;
-		}
-		if ( (lastc != OUT && ISWORD(lastc)) &&
-				(flagch == EOL || (c != OUT && !ISWORD(c))) ) {
-			flagch = EOW;
-		}
-		if (flagch == BOW || flagch == EOW) {
-			st = step(m->g, startst, stopst, st, flagch, st);
-			SP("sboweow", st, c);
-		}
-
-		/* are we done? */
-		if (ISSET(st, stopst))
-			matchp = p;
-		if (EQ(st, empty) || p == stop)
-			break;		/* NOTE BREAK OUT */
-
-		/* no, we must deal with this character */
-		ASSIGN(tmp, st);
-		ASSIGN(st, empty);
-		assert(c != OUT);
-		st = step(m->g, startst, stopst, tmp, c, st);
-		SP("saft", st, c);
-		assert(EQ(step(m->g, startst, stopst, st, NOTHING, st), st));
-		p++;
-	}
-
-	return(matchp);
-}
-
-
-/*
- - step - map set of states reachable before char to set reachable after
- == static states step(struct re_guts *g, sopno start, sopno stop, \
- ==	states bef, int ch, states aft);
- == #define	BOL	(OUT+1)
- == #define	EOL	(BOL+1)
- == #define	BOLEOL	(BOL+2)
- == #define	NOTHING	(BOL+3)
- == #define	BOW	(BOL+4)
- == #define	EOW	(BOL+5)
- == #define	CODEMAX	(BOL+5)		// highest code used
- == #define	NONCHAR(c)	((c) > CHAR_MAX)
- == #define	NNONCHAR	(CODEMAX-CHAR_MAX)
- */
-static states
-step(g, start, stop, bef, ch, aft)
-struct re_guts *g;
-sopno start;			/* start state within strip */
-sopno stop;			/* state after stop state within strip */
-states bef;			/* states reachable before */
-int ch;				/* character or NONCHAR code */
-states aft;			/* states already known reachable after */
-{
-	cset *cs;
-	sop s;
-	sopno pc;
-	onestate here;		/* note, macros know this name */
-	sopno look;
-	int i;
-
-	for (pc = start, INIT(here, pc); pc != stop; pc++, INC(here)) {
-		s = g->strip[pc];
-		switch (OP(s)) {
-		case OEND:
-			assert(pc == stop-1);
-			break;
-		case OCHAR:
-			/* only characters can match */
-			assert(!NONCHAR(ch) || ch != (char)OPND(s));
-			if (ch == (char)OPND(s))
-				FWD(aft, bef, 1);
-			break;
-		case OBOL:
-			if (ch == BOL || ch == BOLEOL)
-				FWD(aft, bef, 1);
-			break;
-		case OEOL:
-			if (ch == EOL || ch == BOLEOL)
-				FWD(aft, bef, 1);
-			break;
-		case OBOW:
-			if (ch == BOW)
-				FWD(aft, bef, 1);
-			break;
-		case OEOW:
-			if (ch == EOW)
-				FWD(aft, bef, 1);
-			break;
-		case OANY:
-			if (!NONCHAR(ch))
-				FWD(aft, bef, 1);
-			break;
-		case OANYOF:
-			cs = &g->sets[OPND(s)];
-			if (!NONCHAR(ch) && CHIN(cs, ch))
-				FWD(aft, bef, 1);
-			break;
-		case OBACK_:		/* ignored here */
-		case O_BACK:
-			FWD(aft, aft, 1);
-			break;
-		case OPLUS_:		/* forward, this is just an empty */
-			FWD(aft, aft, 1);
-			break;
-		case O_PLUS:		/* both forward and back */
-			FWD(aft, aft, 1);
-			i = ISSETBACK(aft, OPND(s));
-			BACK(aft, aft, OPND(s));
-			if (!i && ISSETBACK(aft, OPND(s))) {
-				/* oho, must reconsider loop body */
-				pc -= OPND(s) + 1;
-				INIT(here, pc);
-			}
-			break;
-		case OQUEST_:		/* two branches, both forward */
-			FWD(aft, aft, 1);
-			FWD(aft, aft, OPND(s));
-			break;
-		case O_QUEST:		/* just an empty */
-			FWD(aft, aft, 1);
-			break;
-		case OLPAREN:		/* not significant here */
-		case ORPAREN:
-			FWD(aft, aft, 1);
-			break;
-		case OCH_:		/* mark the first two branches */
-			FWD(aft, aft, 1);
-			assert(OP(g->strip[pc+OPND(s)]) == OOR2);
-			FWD(aft, aft, OPND(s));
-			break;
-		case OOR1:		/* done a branch, find the O_CH */
-			if (ISSTATEIN(aft, here)) {
-				for (look = 1;
-						OP(s = g->strip[pc+look]) != O_CH;
-						look += OPND(s))
-					assert(OP(s) == OOR2);
-				FWD(aft, aft, look);
-			}
-			break;
-		case OOR2:		/* propagate OCH_'s marking */
-			FWD(aft, aft, 1);
-			if (OP(g->strip[pc+OPND(s)]) != O_CH) {
-				assert(OP(g->strip[pc+OPND(s)]) == OOR2);
-				FWD(aft, aft, OPND(s));
-			}
-			break;
-		case O_CH:		/* just empty */
-			FWD(aft, aft, 1);
-			break;
-		default:		/* ooooops... */
-			assert(nope);
-			break;
-		}
-	}
-
-	return(aft);
-}
-
-#ifdef REDEBUG
-/*
- - print - print a set of states
- == #ifdef REDEBUG
- == static void print(struct match *m, char *caption, states st, \
- ==	int ch, FILE *d);
- == #endif
- */
-static void
-print(m, caption, st, ch, d)
-struct match *m;
-char *caption;
-states st;
-int ch;
-FILE *d;
-{
-	struct re_guts *g = m->g;
-	int i;
-	int first = 1;
-
-	if (!(m->eflags&REG_TRACE))
-		return;
-
-	fprintf(d, "%s", caption);
-	if (ch != '\0')
-		fprintf(d, " %s", pchar(ch));
-	for (i = 0; i < g->nstates; i++)
-		if (ISSET(st, i)) {
-			fprintf(d, "%s%d", (first) ? "\t" : ", ", i);
-			first = 0;
-		}
-	fprintf(d, "\n");
-}
-
-/*
- - at - print current situation
- == #ifdef REDEBUG
- == static void at(struct match *m, char *title, char *start, char *stop, \
- ==						sopno startst, sopno stopst);
- == #endif
- */
-static void
-at(m, title, start, stop, startst, stopst)
-struct match *m;
-char *title;
-char *start;
-char *stop;
-sopno startst;
-sopno stopst;
-{
-	if (!(m->eflags&REG_TRACE))
-		return;
-
-	printf("%s %s-", title, pchar(*start));
-	printf("%s ", pchar(*stop));
-	printf("%ld-%ld\n", (long)startst, (long)stopst);
-}
-
-#ifndef PCHARDONE
-#define	PCHARDONE	/* never again */
-/*
- - pchar - make a character printable
- == #ifdef REDEBUG
- == static char *pchar(int ch);
- == #endif
- *
- * Is this identical to regchar() over in debug.c?  Well, yes.  But a
- * duplicate here avoids having a debugging-capable regexec.o tied to
- * a matching debug.o, and this is convenient.  It all disappears in
- * the non-debug compilation anyway, so it doesn't matter much.
- */
-static char *			/* -> representation */
-pchar(ch)
-int ch;
-{
-	static char pbuf[10];
-
-	if (isprint((uch)ch) || ch == ' ')
-		sprintf(pbuf, "%c", ch);
-	else
-		sprintf(pbuf, "\\%o", ch);
-	return(pbuf);
-}
-#endif
-#endif
-
-#undef	matcher
-#undef	fast
-#undef	slow
-#undef	dissect
-#undef	backref
-#undef	step
-#undef	print
-#undef	at
-#undef	match
diff -ruN rexxre/regex/regcomp.c rexxre-patch/regex/regcomp.c
--- rexxre/regex/regcomp.c	2003-05-01 09:58:20.000000000 +1200
+++ rexxre-patch/regex/regcomp.c	1970-01-01 13:00:00.000000000 +1300
@@ -1,2098 +0,0 @@
-/*-
- * Copyright (c) 1992, 1993, 1994 Henry Spencer.
- * Copyright (c) 1992, 1993, 1994
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Henry Spencer.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)regcomp.c	8.5 (Berkeley) 3/20/94
- */
-
-#if defined(LIBC_SCCS) && !defined(lint)
-static char sccsid[] = "@(#)regcomp.c	8.5 (Berkeley) 3/20/94";
-#endif /* LIBC_SCCS and not lint */
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD$");
-
-#include <sys/types.h>
-#include <stdio.h>
-#include <string.h>
-#include <ctype.h>
-#include <limits.h>
-#include <stdlib.h>
-#include <regex.h>
-
-#include "collate.h"
-
-#include "utils.h"
-#include "regex2.h"
-
-#include "cclass.h"
-#include "cname.h"
-
-/* microsoft's c library misses isblank() */
-#if defined(_WIN32) || defined(__EMX__)
-static int isblank(int c)
-{
-   return c == ' ' || c == '\t';
-}
-#endif
-
-
-/*
- * parse structure, passed up and down to avoid global variables and
- * other clumsinesses
- */
-struct parse {
-	char *next;		/* next character in RE */
-	char *end;		/* end of string (-> NUL normally) */
-	int error;		/* has an error been seen? */
-	sop *strip;		/* malloced strip */
-	sopno ssize;		/* malloced strip size (allocated) */
-	sopno slen;		/* malloced strip length (used) */
-	int ncsalloc;		/* number of csets allocated */
-	struct re_guts *g;
-#	define	NPAREN	10	/* we need to remember () 1-9 for back refs */
-	sopno pbegin[NPAREN];	/* -> ( ([0] unused) */
-	sopno pend[NPAREN];	/* -> ) ([0] unused) */
-};
-
-/* ========= begin header generated by ./mkh ========= */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* === regcomp.c === */
-static void p_ere(struct parse *p, int stop);
-static void p_ere_exp(struct parse *p);
-static void p_str(struct parse *p);
-static void p_bre(struct parse *p, int end1, int end2);
-static int p_simp_re(struct parse *p, int starordinary);
-static int p_count(struct parse *p);
-static void p_bracket(struct parse *p);
-static void p_b_term(struct parse *p, cset *cs);
-static void p_b_cclass(struct parse *p, cset *cs);
-static void p_b_eclass(struct parse *p, cset *cs);
-static char p_b_symbol(struct parse *p);
-static char p_b_coll_elem(struct parse *p, int endc);
-static char othercase(int ch);
-static void bothcases(struct parse *p, int ch);
-static void ordinary(struct parse *p, int ch);
-static void nonnewline(struct parse *p);
-static void repeat(struct parse *p, sopno start, int from, int to);
-static int seterr(struct parse *p, int e);
-static cset *allocset(struct parse *p);
-static void freeset(struct parse *p, cset *cs);
-static int freezeset(struct parse *p, cset *cs);
-static int firstch(struct parse *p, cset *cs);
-static int nch(struct parse *p, cset *cs);
-static void mcadd(struct parse *p, cset *cs, char *cp);
-#if used
-static void mcsub(cset *cs, char *cp);
-static int mcin(cset *cs, char *cp);
-static char *mcfind(cset *cs, char *cp);
-#endif
-static void mcinvert(struct parse *p, cset *cs);
-static void mccase(struct parse *p, cset *cs);
-static int isinsets(struct re_guts *g, int c);
-static int samesets(struct re_guts *g, int c1, int c2);
-static void categorize(struct parse *p, struct re_guts *g);
-static sopno dupl(struct parse *p, sopno start, sopno finish);
-static void doemit(struct parse *p, sop op, size_t opnd);
-static void doinsert(struct parse *p, sop op, size_t opnd, sopno pos);
-static void dofwd(struct parse *p, sopno pos, sop value);
-static void enlarge(struct parse *p, sopno size);
-static void stripsnug(struct parse *p, struct re_guts *g);
-static void findmust(struct parse *p, struct re_guts *g);
-static int altoffset(sop *scan, int offset, int mccs);
-static void computejumps(struct parse *p, struct re_guts *g);
-static void computematchjumps(struct parse *p, struct re_guts *g);
-static sopno pluscount(struct parse *p, struct re_guts *g);
-
-#ifdef __cplusplus
-}
-#endif
-/* ========= end header generated by ./mkh ========= */
-
-static char nuls[10];		/* place to point scanner in event of error */
-
-/*
- * macros for use with parse structure
- * BEWARE:  these know that the parse structure is named `p' !!!
- */
-#define	PEEK()	(*p->next)
-#define	PEEK2()	(*(p->next+1))
-#define	MORE()	(p->next < p->end)
-#define	MORE2()	(p->next+1 < p->end)
-#define	SEE(c)	(MORE() && PEEK() == (c))
-#define	SEETWO(a, b)	(MORE() && MORE2() && PEEK() == (a) && PEEK2() == (b))
-#define	EAT(c)	((SEE(c)) ? (NEXT(), 1) : 0)
-#define	EATTWO(a, b)	((SEETWO(a, b)) ? (NEXT2(), 1) : 0)
-#define	NEXT()	(p->next++)
-#define	NEXT2()	(p->next += 2)
-#define	NEXTn(n)	(p->next += (n))
-#define	GETNEXT()	(*p->next++)
-#define	SETERROR(e)	seterr(p, (e))
-#define	REQUIRE(co, e)	((co) || SETERROR(e))
-#define	MUSTSEE(c, e)	(REQUIRE(MORE() && PEEK() == (c), e))
-#define	MUSTEAT(c, e)	(REQUIRE(MORE() && GETNEXT() == (c), e))
-#define	MUSTNOTSEE(c, e)	(REQUIRE(!MORE() || PEEK() != (c), e))
-#define	EMIT(op, sopnd)	doemit(p, (sop)(op), (size_t)(sopnd))
-#define	INSERT(op, pos)	doinsert(p, (sop)(op), HERE()-(pos)+1, pos)
-#define	AHEAD(pos)		dofwd(p, pos, HERE()-(pos))
-#define	ASTERN(sop, pos)	EMIT(sop, HERE()-pos)
-#define	HERE()		(p->slen)
-#define	THERE()		(p->slen - 1)
-#define	THERETHERE()	(p->slen - 2)
-#define	DROP(n)	(p->slen -= (n))
-
-#ifndef NDEBUG
-static int never = 0;		/* for use in asserts; shuts lint up */
-#else
-#define	never	0		/* some <assert.h>s have bugs too */
-#endif
-
-/* Macro used by computejump()/computematchjump() */
-#define MIN(a,b)	((a)<(b)?(a):(b))
-
-/*
- - regcomp - interface for parser and compilation
- = extern int regcomp(regex_t *, const char *, int);
- = #define	REG_BASIC	0000
- = #define	REG_EXTENDED	0001
- = #define	REG_ICASE	0002
- = #define	REG_NOSUB	0004
- = #define	REG_NEWLINE	0010
- = #define	REG_NOSPEC	0020
- = #define	REG_PEND	0040
- = #define	REG_DUMP	0200
- */
-int				/* 0 success, otherwise REG_something */
-regcomp(preg, pattern, cflags)
-regex_t *preg;
-const char *pattern;
-int cflags;
-{
-	struct parse pa;
-	struct re_guts *g;
-	struct parse *p = &pa;
-	int i;
-	size_t len;
-#ifdef REDEBUG
-#	define	GOODFLAGS(f)	(f)
-#else
-#	define	GOODFLAGS(f)	((f)&~REG_DUMP)
-#endif
-
-	cflags = GOODFLAGS(cflags);
-	if ((cflags&REG_EXTENDED) && (cflags&REG_NOSPEC))
-		return(REG_INVARG);
-
-	if (cflags&REG_PEND) {
-		if (preg->re_endp < pattern)
-			return(REG_INVARG);
-		len = preg->re_endp - pattern;
-	} else
-		len = strlen((char *)pattern);
-
-	/* do the mallocs early so failure handling is easy */
-	g = (struct re_guts *)malloc(sizeof(struct re_guts) +
-							(NC-1)*sizeof(cat_t));
-	if (g == NULL)
-		return(REG_ESPACE);
-	p->ssize = len/(size_t)2*(size_t)3 + (size_t)1;	/* ugh */
-	p->strip = (sop *)malloc(p->ssize * sizeof(sop));
-	p->slen = 0;
-	if (p->strip == NULL) {
-		free((char *)g);
-		return(REG_ESPACE);
-	}
-
-	/* set things up */
-	p->g = g;
-	p->next = (char *)pattern;	/* convenience; we do not modify it */
-	p->end = p->next + len;
-	p->error = 0;
-	p->ncsalloc = 0;
-	for (i = 0; i < NPAREN; i++) {
-		p->pbegin[i] = 0;
-		p->pend[i] = 0;
-	}
-	g->csetsize = NC;
-	g->sets = NULL;
-	g->setbits = NULL;
-	g->ncsets = 0;
-	g->cflags = cflags;
-	g->iflags = 0;
-	g->nbol = 0;
-	g->neol = 0;
-	g->must = NULL;
-	g->moffset = -1;
-	g->charjump = NULL;
-	g->matchjump = NULL;
-	g->mlen = 0;
-	g->nsub = 0;
-	g->ncategories = 1;	/* category 0 is "everything else" */
-	g->categories = &g->catspace[-(CHAR_MIN)];
-	(void) memset((char *)g->catspace, 0, NC*sizeof(cat_t));
-	g->backrefs = 0;
-
-	/* do it */
-	EMIT(OEND, 0);
-	g->firststate = THERE();
-	if (cflags&REG_EXTENDED)
-		p_ere(p, OUT);
-	else if (cflags&REG_NOSPEC)
-		p_str(p);
-	else
-		p_bre(p, OUT, OUT);
-	EMIT(OEND, 0);
-	g->laststate = THERE();
-
-	/* tidy up loose ends and fill things in */
-	categorize(p, g);
-	stripsnug(p, g);
-	findmust(p, g);
-	/* only use Boyer-Moore algorithm if the pattern is bigger
-	 * than three characters
-	 */
-	if(g->mlen > 3) {
-		computejumps(p, g);
-		computematchjumps(p, g);
-		if(g->matchjump == NULL && g->charjump != NULL) {
-			free(g->charjump);
-			g->charjump = NULL;
-		}
-	}
-	g->nplus = pluscount(p, g);
-	g->magic = MAGIC2;
-	preg->re_nsub = g->nsub;
-	preg->re_g = g;
-	preg->re_magic = MAGIC1;
-#ifndef REDEBUG
-	/* not debugging, so can't rely on the assert() in regexec() */
-	if (g->iflags&BAD)
-		SETERROR(REG_ASSERT);
-#endif
-
-	/* win or lose, we're done */
-	if (p->error != 0)	/* lose */
-		regfree(preg);
-	return(p->error);
-}
-
-/*
- - p_ere - ERE parser top level, concatenation and alternation
- == static void p_ere(struct parse *p, int stop);
- */
-static void
-p_ere(p, stop)
-struct parse *p;
-int stop;			/* character this ERE should end at */
-{
-	char c;
-	sopno prevback;
-	sopno prevfwd;
-	sopno conc;
-	int first = 1;		/* is this the first alternative? */
-
-	for (;;) {
-		/* do a bunch of concatenated expressions */
-		conc = HERE();
-		while (MORE() && (c = PEEK()) != '|' && c != stop)
-			p_ere_exp(p);
-		(void)REQUIRE(HERE() != conc, REG_EMPTY);	/* require nonempty */
-
-		if (!EAT('|'))
-			break;		/* NOTE BREAK OUT */
-
-		if (first) {
-			INSERT(OCH_, conc);	/* offset is wrong */
-			prevfwd = conc;
-			prevback = conc;
-			first = 0;
-		}
-		ASTERN(OOR1, prevback);
-		prevback = THERE();
-		AHEAD(prevfwd);			/* fix previous offset */
-		prevfwd = HERE();
-		EMIT(OOR2, 0);			/* offset is very wrong */
-	}
-
-	if (!first) {		/* tail-end fixups */
-		AHEAD(prevfwd);
-		ASTERN(O_CH, prevback);
-	}
-
-	assert(!MORE() || SEE(stop));
-}
-
-/*
- - p_ere_exp - parse one subERE, an atom possibly followed by a repetition op
- == static void p_ere_exp(struct parse *p);
- */
-static void
-p_ere_exp(p)
-struct parse *p;
-{
-	char c;
-	sopno pos;
-	int count;
-	int count2;
-	sopno subno;
-	int wascaret = 0;
-
-	assert(MORE());		/* caller should have ensured this */
-	c = GETNEXT();
-
-	pos = HERE();
-	switch (c) {
-	case '(':
-		(void)REQUIRE(MORE(), REG_EPAREN);
-		p->g->nsub++;
-		subno = p->g->nsub;
-		if (subno < NPAREN)
-			p->pbegin[subno] = HERE();
-		EMIT(OLPAREN, subno);
-		if (!SEE(')'))
-			p_ere(p, ')');
-		if (subno < NPAREN) {
-			p->pend[subno] = HERE();
-			assert(p->pend[subno] != 0);
-		}
-		EMIT(ORPAREN, subno);
-		(void)MUSTEAT(')', REG_EPAREN);
-		break;
-#ifndef POSIX_MISTAKE
-	case ')':		/* happens only if no current unmatched ( */
-		/*
-		 * You may ask, why the ifndef?  Because I didn't notice
-		 * this until slightly too late for 1003.2, and none of the
-		 * other 1003.2 regular-expression reviewers noticed it at
-		 * all.  So an unmatched ) is legal POSIX, at least until
-		 * we can get it fixed.
-		 */
-		SETERROR(REG_EPAREN);
-		break;
-#endif
-	case '^':
-		EMIT(OBOL, 0);
-		p->g->iflags |= USEBOL;
-		p->g->nbol++;
-		wascaret = 1;
-		break;
-	case '$':
-		EMIT(OEOL, 0);
-		p->g->iflags |= USEEOL;
-		p->g->neol++;
-		break;
-	case '|':
-		SETERROR(REG_EMPTY);
-		break;
-	case '*':
-	case '+':
-	case '?':
-		SETERROR(REG_BADRPT);
-		break;
-	case '.':
-		if (p->g->cflags&REG_NEWLINE)
-			nonnewline(p);
-		else
-			EMIT(OANY, 0);
-		break;
-	case '[':
-		p_bracket(p);
-		break;
-	case '\\':
-		(void)REQUIRE(MORE(), REG_EESCAPE);
-		c = GETNEXT();
-		ordinary(p, c);
-		break;
-	case '{':		/* okay as ordinary except if digit follows */
-		(void)REQUIRE(!MORE() || !isdigit((uch)PEEK()), REG_BADRPT);
-		/* FALLTHROUGH */
-	default:
-		ordinary(p, c);
-		break;
-	}
-
-	if (!MORE())
-		return;
-	c = PEEK();
-	/* we call { a repetition if followed by a digit */
-	if (!( c == '*' || c == '+' || c == '?' ||
-				(c == '{' && MORE2() && isdigit((uch)PEEK2())) ))
-		return;		/* no repetition, we're done */
-	NEXT();
-
-	(void)REQUIRE(!wascaret, REG_BADRPT);
-	switch (c) {
-	case '*':	/* implemented as +? */
-		/* this case does not require the (y|) trick, noKLUDGE */
-		INSERT(OPLUS_, pos);
-		ASTERN(O_PLUS, pos);
-		INSERT(OQUEST_, pos);
-		ASTERN(O_QUEST, pos);
-		break;
-	case '+':
-		INSERT(OPLUS_, pos);
-		ASTERN(O_PLUS, pos);
-		break;
-	case '?':
-		/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
-		INSERT(OCH_, pos);		/* offset slightly wrong */
-		ASTERN(OOR1, pos);		/* this one's right */
-		AHEAD(pos);			/* fix the OCH_ */
-		EMIT(OOR2, 0);			/* offset very wrong... */
-		AHEAD(THERE());			/* ...so fix it */
-		ASTERN(O_CH, THERETHERE());
-		break;
-	case '{':
-		count = p_count(p);
-		if (EAT(',')) {
-			if (isdigit((uch)PEEK())) {
-				count2 = p_count(p);
-				(void)REQUIRE(count <= count2, REG_BADBR);
-			} else		/* single number with comma */
-				count2 = INFINITY;
-		} else		/* just a single number */
-			count2 = count;
-		repeat(p, pos, count, count2);
-		if (!EAT('}')) {	/* error heuristics */
-			while (MORE() && PEEK() != '}')
-				NEXT();
-			(void)REQUIRE(MORE(), REG_EBRACE);
-			SETERROR(REG_BADBR);
-		}
-		break;
-	}
-
-	if (!MORE())
-		return;
-	c = PEEK();
-	if (!( c == '*' || c == '+' || c == '?' ||
-				(c == '{' && MORE2() && isdigit((uch)PEEK2())) ) )
-		return;
-	SETERROR(REG_BADRPT);
-}
-
-/*
- - p_str - string (no metacharacters) "parser"
- == static void p_str(struct parse *p);
- */
-static void
-p_str(p)
-struct parse *p;
-{
-	(void)REQUIRE(MORE(), REG_EMPTY);
-	while (MORE())
-		ordinary(p, GETNEXT());
-}
-
-/*
- - p_bre - BRE parser top level, anchoring and concatenation
- == static void p_bre(struct parse *p, int end1, \
- ==	int end2);
- * Giving end1 as OUT essentially eliminates the end1/end2 check.
- *
- * This implementation is a bit of a kludge, in that a trailing $ is first
- * taken as an ordinary character and then revised to be an anchor.  The
- * only undesirable side effect is that '$' gets included as a character
- * category in such cases.  This is fairly harmless; not worth fixing.
- * The amount of lookahead needed to avoid this kludge is excessive.
- */
-static void
-p_bre(p, end1, end2)
-struct parse *p;
-int end1;			/* first terminating character */
-int end2;			/* second terminating character */
-{
-	sopno start = HERE();
-	int first = 1;			/* first subexpression? */
-	int wasdollar = 0;
-
-	if (EAT('^')) {
-		EMIT(OBOL, 0);
-		p->g->iflags |= USEBOL;
-		p->g->nbol++;
-	}
-	while (MORE() && !SEETWO(end1, end2)) {
-		wasdollar = p_simp_re(p, first);
-		first = 0;
-	}
-	if (wasdollar) {	/* oops, that was a trailing anchor */
-		DROP(1);
-		EMIT(OEOL, 0);
-		p->g->iflags |= USEEOL;
-		p->g->neol++;
-	}
-
-	(void)REQUIRE(HERE() != start, REG_EMPTY);	/* require nonempty */
-}
-
-/*
- - p_simp_re - parse a simple RE, an atom possibly followed by a repetition
- == static int p_simp_re(struct parse *p, int starordinary);
- */
-static int			/* was the simple RE an unbackslashed $? */
-p_simp_re(p, starordinary)
-struct parse *p;
-int starordinary;		/* is a leading * an ordinary character? */
-{
-	int c;
-	int count;
-	int count2;
-	sopno pos;
-	int i;
-	sopno subno;
-#	define	BACKSL	(1<<CHAR_BIT)
-
-	pos = HERE();		/* repetion op, if any, covers from here */
-
-	assert(MORE());		/* caller should have ensured this */
-	c = GETNEXT();
-	if (c == '\\') {
-		(void)REQUIRE(MORE(), REG_EESCAPE);
-		c = BACKSL | GETNEXT();
-	}
-	switch (c) {
-	case '.':
-		if (p->g->cflags&REG_NEWLINE)
-			nonnewline(p);
-		else
-			EMIT(OANY, 0);
-		break;
-	case '[':
-		p_bracket(p);
-		break;
-	case BACKSL|'{':
-		SETERROR(REG_BADRPT);
-		break;
-	case BACKSL|'(':
-		p->g->nsub++;
-		subno = p->g->nsub;
-		if (subno < NPAREN)
-			p->pbegin[subno] = HERE();
-		EMIT(OLPAREN, subno);
-		/* the MORE here is an error heuristic */
-		if (MORE() && !SEETWO('\\', ')'))
-			p_bre(p, '\\', ')');
-		if (subno < NPAREN) {
-			p->pend[subno] = HERE();
-			assert(p->pend[subno] != 0);
-		}
-		EMIT(ORPAREN, subno);
-		(void)REQUIRE(EATTWO('\\', ')'), REG_EPAREN);
-		break;
-	case BACKSL|')':	/* should not get here -- must be user */
-	case BACKSL|'}':
-		SETERROR(REG_EPAREN);
-		break;
-	case BACKSL|'1':
-	case BACKSL|'2':
-	case BACKSL|'3':
-	case BACKSL|'4':
-	case BACKSL|'5':
-	case BACKSL|'6':
-	case BACKSL|'7':
-	case BACKSL|'8':
-	case BACKSL|'9':
-		i = (c&~BACKSL) - '0';
-		assert(i < NPAREN);
-		if (p->pend[i] != 0) {
-			assert(i <= p->g->nsub);
-			EMIT(OBACK_, i);
-			assert(p->pbegin[i] != 0);
-			assert(OP(p->strip[p->pbegin[i]]) == OLPAREN);
-			assert(OP(p->strip[p->pend[i]]) == ORPAREN);
-			(void) dupl(p, p->pbegin[i]+1, p->pend[i]);
-			EMIT(O_BACK, i);
-		} else
-			SETERROR(REG_ESUBREG);
-		p->g->backrefs = 1;
-		break;
-	case '*':
-		(void)REQUIRE(starordinary, REG_BADRPT);
-		/* FALLTHROUGH */
-	default:
-		ordinary(p, (char)c);
-		break;
-	}
-
-	if (EAT('*')) {		/* implemented as +? */
-		/* this case does not require the (y|) trick, noKLUDGE */
-		INSERT(OPLUS_, pos);
-		ASTERN(O_PLUS, pos);
-		INSERT(OQUEST_, pos);
-		ASTERN(O_QUEST, pos);
-	} else if (EATTWO('\\', '{')) {
-		count = p_count(p);
-		if (EAT(',')) {
-			if (MORE() && isdigit((uch)PEEK())) {
-				count2 = p_count(p);
-				(void)REQUIRE(count <= count2, REG_BADBR);
-			} else		/* single number with comma */
-				count2 = INFINITY;
-		} else		/* just a single number */
-			count2 = count;
-		repeat(p, pos, count, count2);
-		if (!EATTWO('\\', '}')) {	/* error heuristics */
-			while (MORE() && !SEETWO('\\', '}'))
-				NEXT();
-			(void)REQUIRE(MORE(), REG_EBRACE);
-			SETERROR(REG_BADBR);
-		}
-	} else if (c == '$')     /* $ (but not \$) ends it */
-		return(1);
-
-	return(0);
-}
-
-/*
- - p_count - parse a repetition count
- == static int p_count(struct parse *p);
- */
-static int			/* the value */
-p_count(p)
-struct parse *p;
-{
-	int count = 0;
-	int ndigits = 0;
-
-	while (MORE() && isdigit((uch)PEEK()) && count <= DUPMAX) {
-		count = count*10 + (GETNEXT() - '0');
-		ndigits++;
-	}
-
-	(void)REQUIRE(ndigits > 0 && count <= DUPMAX, REG_BADBR);
-	return(count);
-}
-
-/*
- - p_bracket - parse a bracketed character list
- == static void p_bracket(struct parse *p);
- *
- * Note a significant property of this code:  if the allocset() did SETERROR,
- * no set operations are done.
- */
-static void
-p_bracket(p)
-struct parse *p;
-{
-	cset *cs = allocset(p);
-	int invert = 0;
-
-	/* Dept of Truly Sickening Special-Case Kludges */
-	if (p->next + 5 < p->end && strncmp(p->next, "[:<:]]", 6) == 0) {
-		EMIT(OBOW, 0);
-		NEXTn(6);
-		return;
-	}
-	if (p->next + 5 < p->end && strncmp(p->next, "[:>:]]", 6) == 0) {
-		EMIT(OEOW, 0);
-		NEXTn(6);
-		return;
-	}
-
-	if (EAT('^'))
-		invert++;	/* make note to invert set at end */
-	if (EAT(']'))
-		CHadd(cs, ']');
-	else if (EAT('-'))
-		CHadd(cs, '-');
-	while (MORE() && PEEK() != ']' && !SEETWO('-', ']'))
-		p_b_term(p, cs);
-	if (EAT('-'))
-		CHadd(cs, '-');
-	(void)MUSTEAT(']', REG_EBRACK);
-
-	if (p->error != 0)	/* don't mess things up further */
-		return;
-
-	if (p->g->cflags&REG_ICASE) {
-		int i;
-		int ci;
-
-		for (i = p->g->csetsize - 1; i >= 0; i--)
-			if (CHIN(cs, i) && isalpha(i)) {
-				ci = othercase(i);
-				if (ci != i)
-					CHadd(cs, ci);
-			}
-		if (cs->multis != NULL)
-			mccase(p, cs);
-	}
-	if (invert) {
-		int i;
-
-		for (i = p->g->csetsize - 1; i >= 0; i--)
-			if (CHIN(cs, i))
-				CHsub(cs, i);
-			else
-				CHadd(cs, i);
-		if (p->g->cflags&REG_NEWLINE)
-			CHsub(cs, '\n');
-		if (cs->multis != NULL)
-			mcinvert(p, cs);
-	}
-
-	assert(cs->multis == NULL);		/* xxx */
-
-	if (nch(p, cs) == 1) {		/* optimize singleton sets */
-		ordinary(p, firstch(p, cs));
-		freeset(p, cs);
-	} else
-		EMIT(OANYOF, freezeset(p, cs));
-}
-
-/*
- - p_b_term - parse one term of a bracketed character list
- == static void p_b_term(struct parse *p, cset *cs);
- */
-static void
-p_b_term(p, cs)
-struct parse *p;
-cset *cs;
-{
-	char c;
-	char start, finish;
-	int i;
-
-	/* classify what we've got */
-	switch ((MORE()) ? PEEK() : '\0') {
-	case '[':
-		c = (MORE2()) ? PEEK2() : '\0';
-		break;
-	case '-':
-		SETERROR(REG_ERANGE);
-		return;			/* NOTE RETURN */
-		break;
-	default:
-		c = '\0';
-		break;
-	}
-
-	switch (c) {
-	case ':':		/* character class */
-		NEXT2();
-		(void)REQUIRE(MORE(), REG_EBRACK);
-		c = PEEK();
-		(void)REQUIRE(c != '-' && c != ']', REG_ECTYPE);
-		p_b_cclass(p, cs);
-		(void)REQUIRE(MORE(), REG_EBRACK);
-		(void)REQUIRE(EATTWO(':', ']'), REG_ECTYPE);
-		break;
-	case '=':		/* equivalence class */
-		NEXT2();
-		(void)REQUIRE(MORE(), REG_EBRACK);
-		c = PEEK();
-		(void)REQUIRE(c != '-' && c != ']', REG_ECOLLATE);
-		p_b_eclass(p, cs);
-		(void)REQUIRE(MORE(), REG_EBRACK);
-		(void)REQUIRE(EATTWO('=', ']'), REG_ECOLLATE);
-		break;
-	default:		/* symbol, ordinary character, or range */
-/* xxx revision needed for multichar stuff */
-		start = p_b_symbol(p);
-		if (SEE('-') && MORE2() && PEEK2() != ']') {
-			/* range */
-			NEXT();
-			if (EAT('-'))
-				finish = '-';
-			else
-				finish = p_b_symbol(p);
-		} else
-			finish = start;
-		if (start == finish)
-			CHadd(cs, start);
-		else {
-			if (__collate_load_error) {
-				(void)REQUIRE((uch)start <= (uch)finish, REG_ERANGE);
-				for (i = (uch)start; i <= (uch)finish; i++)
-					CHadd(cs, i);
-			} else {
-				(void)REQUIRE(__collate_range_cmp(start, finish) <= 0, REG_ERANGE);
-				for (i = CHAR_MIN; i <= CHAR_MAX; i++) {
-					if (   __collate_range_cmp(start, i) <= 0
-					    && __collate_range_cmp(i, finish) <= 0
-					   )
-						CHadd(cs, i);
-				}
-			}
-		}
-		break;
-	}
-}
-
-/*
- - p_b_cclass - parse a character-class name and deal with it
- == static void p_b_cclass(struct parse *p, cset *cs);
- */
-static void
-p_b_cclass(p, cs)
-struct parse *p;
-cset *cs;
-{
-	int c;
-	char *sp = p->next;
-	struct cclass *cp;
-	size_t len;
-
-	while (MORE() && isalpha((uch)PEEK()))
-		NEXT();
-	len = p->next - sp;
-	for (cp = cclasses; cp->name != NULL; cp++)
-		if (strncmp(cp->name, sp, len) == 0 && cp->name[len] == '\0')
-			break;
-	if (cp->name == NULL) {
-		/* oops, didn't find it */
-		SETERROR(REG_ECTYPE);
-		return;
-	}
-
-	switch (cp->fidx) {
-	case CALNUM:
-		for (c = CHAR_MIN; c <= CHAR_MAX; c++)
-			if (isalnum((uch)c))
-				CHadd(cs, c);
-		break;
-	case CALPHA:
-		for (c = CHAR_MIN; c <= CHAR_MAX; c++)
-			if (isalpha((uch)c))
-				CHadd(cs, c);
-		break;
-	case CBLANK:
-		for (c = CHAR_MIN; c <= CHAR_MAX; c++)
-			if (isblank((uch)c))
-				CHadd(cs, c);
-		break;
-	case CCNTRL:
-		for (c = CHAR_MIN; c <= CHAR_MAX; c++)
-			if (iscntrl((uch)c))
-				CHadd(cs, c);
-		break;
-	case CDIGIT:
-		for (c = CHAR_MIN; c <= CHAR_MAX; c++)
-			if (isdigit((uch)c))
-				CHadd(cs, c);
-		break;
-	case CGRAPH:
-		for (c = CHAR_MIN; c <= CHAR_MAX; c++)
-			if (isgraph((uch)c))
-				CHadd(cs, c);
-		break;
-	case CLOWER:
-		for (c = CHAR_MIN; c <= CHAR_MAX; c++)
-			if (islower((uch)c))
-				CHadd(cs, c);
-		break;
-	case CPRINT:
-		for (c = CHAR_MIN; c <= CHAR_MAX; c++)
-			if (isprint((uch)c))
-				CHadd(cs, c);
-		break;
-	case CPUNCT:
-		for (c = CHAR_MIN; c <= CHAR_MAX; c++)
-			if (ispunct((uch)c))
-				CHadd(cs, c);
-		break;
-	case CSPACE:
-		for (c = CHAR_MIN; c <= CHAR_MAX; c++)
-			if (isspace((uch)c))
-				CHadd(cs, c);
-		break;
-	case CUPPER:
-		for (c = CHAR_MIN; c <= CHAR_MAX; c++)
-			if (isupper((uch)c))
-				CHadd(cs, c);
-		break;
-	case CXDIGIT:
-		for (c = CHAR_MIN; c <= CHAR_MAX; c++)
-			if (isxdigit((uch)c))
-				CHadd(cs, c);
-		break;
-	}
-#if 0
-	for (u = cp->multis; *u != '\0'; u += strlen(u) + 1)
-		MCadd(p, cs, u);
-#endif
-}
-
-/*
- - p_b_eclass - parse an equivalence-class name and deal with it
- == static void p_b_eclass(struct parse *p, cset *cs);
- *
- * This implementation is incomplete. xxx
- */
-static void
-p_b_eclass(p, cs)
-struct parse *p;
-cset *cs;
-{
-	char c;
-
-	c = p_b_coll_elem(p, '=');
-	CHadd(cs, c);
-}
-
-/*
- - p_b_symbol - parse a character or [..]ed multicharacter collating symbol
- == static char p_b_symbol(struct parse *p);
- */
-static char			/* value of symbol */
-p_b_symbol(p)
-struct parse *p;
-{
-	char value;
-
-	(void)REQUIRE(MORE(), REG_EBRACK);
-	if (!EATTWO('[', '.'))
-		return(GETNEXT());
-
-	/* collating symbol */
-	value = p_b_coll_elem(p, '.');
-	(void)REQUIRE(EATTWO('.', ']'), REG_ECOLLATE);
-	return(value);
-}
-
-/*
- - p_b_coll_elem - parse a collating-element name and look it up
- == static char p_b_coll_elem(struct parse *p, int endc);
- */
-static char			/* value of collating element */
-p_b_coll_elem(p, endc)
-struct parse *p;
-int endc;			/* name ended by endc,']' */
-{
-	char *sp = p->next;
-	struct cname *cp;
-	int len;
-
-	while (MORE() && !SEETWO(endc, ']'))
-		NEXT();
-	if (!MORE()) {
-		SETERROR(REG_EBRACK);
-		return(0);
-	}
-	len = p->next - sp;
-	for (cp = cnames; cp->name != NULL; cp++)
-		if (strncmp(cp->name, sp, len) == 0 && cp->name[len] == '\0')
-			return(cp->code);	/* known name */
-	if (len == 1)
-		return(*sp);	/* single character */
-	SETERROR(REG_ECOLLATE);			/* neither */
-	return(0);
-}
-
-/*
- - othercase - return the case counterpart of an alphabetic
- == static char othercase(int ch);
- */
-static char			/* if no counterpart, return ch */
-othercase(ch)
-int ch;
-{
-	ch = (uch)ch;
-	assert(isalpha(ch));
-	if (isupper(ch))
-		return(tolower(ch));
-	else if (islower(ch))
-		return(toupper(ch));
-	else			/* peculiar, but could happen */
-		return(ch);
-}
-
-/*
- - bothcases - emit a dualcase version of a two-case character
- == static void bothcases(struct parse *p, int ch);
- *
- * Boy, is this implementation ever a kludge...
- */
-static void
-bothcases(p, ch)
-struct parse *p;
-int ch;
-{
-	char *oldnext = p->next;
-	char *oldend = p->end;
-	char bracket[3];
-
-	ch = (uch)ch;
-	assert(othercase(ch) != ch);	/* p_bracket() would recurse */
-	p->next = bracket;
-	p->end = bracket+2;
-	bracket[0] = ch;
-	bracket[1] = ']';
-	bracket[2] = '\0';
-	p_bracket(p);
-	assert(p->next == bracket+2);
-	p->next = oldnext;
-	p->end = oldend;
-}
-
-/*
- - ordinary - emit an ordinary character
- == static void ordinary(struct parse *p, int ch);
- */
-static void
-ordinary(p, ch)
-struct parse *p;
-int ch;
-{
-	cat_t *cap = p->g->categories;
-
-	if ((p->g->cflags&REG_ICASE) && isalpha((uch)ch) && othercase(ch) != ch)
-		bothcases(p, ch);
-	else {
-		EMIT(OCHAR, (uch)ch);
-		if (cap[ch] == 0)
-			cap[ch] = p->g->ncategories++;
-	}
-}
-
-/*
- - nonnewline - emit REG_NEWLINE version of OANY
- == static void nonnewline(struct parse *p);
- *
- * Boy, is this implementation ever a kludge...
- */
-static void
-nonnewline(p)
-struct parse *p;
-{
-	char *oldnext = p->next;
-	char *oldend = p->end;
-	char bracket[4];
-
-	p->next = bracket;
-	p->end = bracket+3;
-	bracket[0] = '^';
-	bracket[1] = '\n';
-	bracket[2] = ']';
-	bracket[3] = '\0';
-	p_bracket(p);
-	assert(p->next == bracket+3);
-	p->next = oldnext;
-	p->end = oldend;
-}
-
-/*
- - repeat - generate code for a bounded repetition, recursively if needed
- == static void repeat(struct parse *p, sopno start, int from, int to);
- */
-static void
-repeat(p, start, from, to)
-struct parse *p;
-sopno start;			/* operand from here to end of strip */
-int from;			/* repeated from this number */
-int to;				/* to this number of times (maybe INFINITY) */
-{
-	sopno finish = HERE();
-#	define	N	2
-#	define	INF	3
-#	define	REP(f, t)	((f)*8 + (t))
-#	define	MAP(n)	(((n) <= 1) ? (n) : ((n) == INFINITY) ? INF : N)
-	sopno copy;
-
-	if (p->error != 0)	/* head off possible runaway recursion */
-		return;
-
-	assert(from <= to);
-
-	switch (REP(MAP(from), MAP(to))) {
-	case REP(0, 0):			/* must be user doing this */
-		DROP(finish-start);	/* drop the operand */
-		break;
-	case REP(0, 1):			/* as x{1,1}? */
-	case REP(0, N):			/* as x{1,n}? */
-	case REP(0, INF):		/* as x{1,}? */
-		/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
-		INSERT(OCH_, start);		/* offset is wrong... */
-		repeat(p, start+1, 1, to);
-		ASTERN(OOR1, start);
-		AHEAD(start);			/* ... fix it */
-		EMIT(OOR2, 0);
-		AHEAD(THERE());
-		ASTERN(O_CH, THERETHERE());
-		break;
-	case REP(1, 1):			/* trivial case */
-		/* done */
-		break;
-	case REP(1, N):			/* as x?x{1,n-1} */
-		/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
-		INSERT(OCH_, start);
-		ASTERN(OOR1, start);
-		AHEAD(start);
-		EMIT(OOR2, 0);			/* offset very wrong... */
-		AHEAD(THERE());			/* ...so fix it */
-		ASTERN(O_CH, THERETHERE());
-		copy = dupl(p, start+1, finish+1);
-		assert(copy == finish+4);
-		repeat(p, copy, 1, to-1);
-		break;
-	case REP(1, INF):		/* as x+ */
-		INSERT(OPLUS_, start);
-		ASTERN(O_PLUS, start);
-		break;
-	case REP(N, N):			/* as xx{m-1,n-1} */
-		copy = dupl(p, start, finish);
-		repeat(p, copy, from-1, to-1);
-		break;
-	case REP(N, INF):		/* as xx{n-1,INF} */
-		copy = dupl(p, start, finish);
-		repeat(p, copy, from-1, to);
-		break;
-	default:			/* "can't happen" */
-		SETERROR(REG_ASSERT);	/* just in case */
-		break;
-	}
-}
-
-/*
- - seterr - set an error condition
- == static int seterr(struct parse *p, int e);
- */
-static int			/* useless but makes type checking happy */
-seterr(p, e)
-struct parse *p;
-int e;
-{
-	if (p->error == 0)	/* keep earliest error condition */
-		p->error = e;
-	p->next = nuls;		/* try to bring things to a halt */
-	p->end = nuls;
-	return(0);		/* make the return value well-defined */
-}
-
-/*
- - allocset - allocate a set of characters for []
- == static cset *allocset(struct parse *p);
- */
-static cset *
-allocset(p)
-struct parse *p;
-{
-	int no = p->g->ncsets++;
-	size_t nc;
-	size_t nbytes;
-	cset *cs;
-	size_t css = (size_t)p->g->csetsize;
-	int i;
-
-	if (no >= p->ncsalloc) {	/* need another column of space */
-		p->ncsalloc += CHAR_BIT;
-		nc = p->ncsalloc;
-		assert(nc % CHAR_BIT == 0);
-		nbytes = nc / CHAR_BIT * css;
-		if (p->g->sets == NULL)
-			p->g->sets = (cset *)malloc(nc * sizeof(cset));
-		else
-			p->g->sets = (cset *)realloc((char *)p->g->sets,
-							nc * sizeof(cset));
-		if (p->g->setbits == NULL)
-			p->g->setbits = (uch *)malloc(nbytes);
-		else {
-			p->g->setbits = (uch *)realloc((char *)p->g->setbits,
-								nbytes);
-			/* xxx this isn't right if setbits is now NULL */
-			for (i = 0; i < no; i++)
-				p->g->sets[i].ptr = p->g->setbits + css*(i/CHAR_BIT);
-		}
-		if (p->g->sets != NULL && p->g->setbits != NULL)
-			(void) memset((char *)p->g->setbits + (nbytes - css),
-								0, css);
-		else {
-			no = 0;
-			SETERROR(REG_ESPACE);
-			/* caller's responsibility not to do set ops */
-		}
-	}
-
-	assert(p->g->sets != NULL);	/* xxx */
-	cs = &p->g->sets[no];
-	cs->ptr = p->g->setbits + css*((no)/CHAR_BIT);
-	cs->mask = 1 << ((no) % CHAR_BIT);
-	cs->hash = 0;
-	cs->smultis = 0;
-	cs->multis = NULL;
-
-	return(cs);
-}
-
-/*
- - freeset - free a now-unused set
- == static void freeset(struct parse *p, cset *cs);
- */
-static void
-freeset(p, cs)
-struct parse *p;
-cset *cs;
-{
-	int i;
-	cset *top = &p->g->sets[p->g->ncsets];
-	size_t css = (size_t)p->g->csetsize;
-
-	for (i = 0; i < css; i++)
-		CHsub(cs, i);
-	if (cs == top-1)	/* recover only the easy case */
-		p->g->ncsets--;
-}
-
-/*
- - freezeset - final processing on a set of characters
- == static int freezeset(struct parse *p, cset *cs);
- *
- * The main task here is merging identical sets.  This is usually a waste
- * of time (although the hash code minimizes the overhead), but can win
- * big if REG_ICASE is being used.  REG_ICASE, by the way, is why the hash
- * is done using addition rather than xor -- all ASCII [aA] sets xor to
- * the same value!
- */
-static int			/* set number */
-freezeset(p, cs)
-struct parse *p;
-cset *cs;
-{
-	short h = cs->hash;
-	int i;
-	cset *top = &p->g->sets[p->g->ncsets];
-	cset *cs2;
-	size_t css = (size_t)p->g->csetsize;
-
-	/* look for an earlier one which is the same */
-	for (cs2 = &p->g->sets[0]; cs2 < top; cs2++)
-		if (cs2->hash == h && cs2 != cs) {
-			/* maybe */
-			for (i = 0; i < css; i++)
-				if (!!CHIN(cs2, i) != !!CHIN(cs, i))
-					break;		/* no */
-			if (i == css)
-				break;			/* yes */
-		}
-
-	if (cs2 < top) {	/* found one */
-		freeset(p, cs);
-		cs = cs2;
-	}
-
-	return((int)(cs - p->g->sets));
-}
-
-/*
- - firstch - return first character in a set (which must have at least one)
- == static int firstch(struct parse *p, cset *cs);
- */
-static int			/* character; there is no "none" value */
-firstch(p, cs)
-struct parse *p;
-cset *cs;
-{
-	int i;
-	size_t css = (size_t)p->g->csetsize;
-
-	for (i = 0; i < css; i++)
-		if (CHIN(cs, i))
-			return((char)i);
-	assert(never);
-	return(0);		/* arbitrary */
-}
-
-/*
- - nch - number of characters in a set
- == static int nch(struct parse *p, cset *cs);
- */
-static int
-nch(p, cs)
-struct parse *p;
-cset *cs;
-{
-	int i;
-	size_t css = (size_t)p->g->csetsize;
-	int n = 0;
-
-	for (i = 0; i < css; i++)
-		if (CHIN(cs, i))
-			n++;
-	return(n);
-}
-
-/*
- - mcadd - add a collating element to a cset
- == static void mcadd(struct parse *p, cset *cs, \
- ==	char *cp);
- */
-static void
-mcadd(p, cs, cp)
-struct parse *p;
-cset *cs;
-char *cp;
-{
-	size_t oldend = cs->smultis;
-
-	cs->smultis += strlen(cp) + 1;
-	if (cs->multis == NULL)
-		cs->multis = malloc(cs->smultis);
-	else
-		cs->multis = realloc(cs->multis, cs->smultis);
-	if (cs->multis == NULL) {
-		SETERROR(REG_ESPACE);
-		return;
-	}
-
-	(void) strcpy(cs->multis + oldend - 1, cp);
-	cs->multis[cs->smultis - 1] = '\0';
-}
-
-#if used
-/*
- - mcsub - subtract a collating element from a cset
- == static void mcsub(cset *cs, char *cp);
- */
-static void
-mcsub(cs, cp)
-cset *cs;
-char *cp;
-{
-	char *fp = mcfind(cs, cp);
-	size_t len = strlen(fp);
-
-	assert(fp != NULL);
-	(void) memmove(fp, fp + len + 1,
-				cs->smultis - (fp + len + 1 - cs->multis));
-	cs->smultis -= len;
-
-	if (cs->smultis == 0) {
-		free(cs->multis);
-		cs->multis = NULL;
-		return;
-	}
-
-	cs->multis = realloc(cs->multis, cs->smultis);
-	assert(cs->multis != NULL);
-}
-
-/*
- - mcin - is a collating element in a cset?
- == static int mcin(cset *cs, char *cp);
- */
-static int
-mcin(cs, cp)
-cset *cs;
-char *cp;
-{
-	return(mcfind(cs, cp) != NULL);
-}
-
-/*
- - mcfind - find a collating element in a cset
- == static char *mcfind(cset *cs, char *cp);
- */
-static char *
-mcfind(cs, cp)
-cset *cs;
-char *cp;
-{
-	char *p;
-
-	if (cs->multis == NULL)
-		return(NULL);
-	for (p = cs->multis; *p != '\0'; p += strlen(p) + 1)
-		if (strcmp(cp, p) == 0)
-			return(p);
-	return(NULL);
-}
-#endif
-
-/*
- - mcinvert - invert the list of collating elements in a cset
- == static void mcinvert(struct parse *p, cset *cs);
- *
- * This would have to know the set of possibilities.  Implementation
- * is deferred.
- */
-static void
-mcinvert(p, cs)
-struct parse *p;
-cset *cs;
-{
-	assert(cs->multis == NULL);	/* xxx */
-}
-
-/*
- - mccase - add case counterparts of the list of collating elements in a cset
- == static void mccase(struct parse *p, cset *cs);
- *
- * This would have to know the set of possibilities.  Implementation
- * is deferred.
- */
-static void
-mccase(p, cs)
-struct parse *p;
-cset *cs;
-{
-	assert(cs->multis == NULL);	/* xxx */
-}
-
-/*
- - isinsets - is this character in any sets?
- == static int isinsets(struct re_guts *g, int c);
- */
-static int			/* predicate */
-isinsets(g, c)
-struct re_guts *g;
-int c;
-{
-	uch *col;
-	int i;
-	int ncols = (g->ncsets+(CHAR_BIT-1)) / CHAR_BIT;
-	unsigned uc = (uch)c;
-
-	for (i = 0, col = g->setbits; i < ncols; i++, col += g->csetsize)
-		if (col[uc] != 0)
-			return(1);
-	return(0);
-}
-
-/*
- - samesets - are these two characters in exactly the same sets?
- == static int samesets(struct re_guts *g, int c1, int c2);
- */
-static int			/* predicate */
-samesets(g, c1, c2)
-struct re_guts *g;
-int c1;
-int c2;
-{
-	uch *col;
-	int i;
-	int ncols = (g->ncsets+(CHAR_BIT-1)) / CHAR_BIT;
-	unsigned uc1 = (uch)c1;
-	unsigned uc2 = (uch)c2;
-
-	for (i = 0, col = g->setbits; i < ncols; i++, col += g->csetsize)
-		if (col[uc1] != col[uc2])
-			return(0);
-	return(1);
-}
-
-/*
- - categorize - sort out character categories
- == static void categorize(struct parse *p, struct re_guts *g);
- */
-static void
-categorize(p, g)
-struct parse *p;
-struct re_guts *g;
-{
-	cat_t *cats = g->categories;
-	int c;
-	int c2;
-	cat_t cat;
-
-	/* avoid making error situations worse */
-	if (p->error != 0)
-		return;
-
-	for (c = CHAR_MIN; c <= CHAR_MAX; c++)
-		if (cats[c] == 0 && isinsets(g, c)) {
-			cat = g->ncategories++;
-			cats[c] = cat;
-			for (c2 = c+1; c2 <= CHAR_MAX; c2++)
-				if (cats[c2] == 0 && samesets(g, c, c2))
-					cats[c2] = cat;
-		}
-}
-
-/*
- - dupl - emit a duplicate of a bunch of sops
- == static sopno dupl(struct parse *p, sopno start, sopno finish);
- */
-static sopno			/* start of duplicate */
-dupl(p, start, finish)
-struct parse *p;
-sopno start;			/* from here */
-sopno finish;			/* to this less one */
-{
-	sopno ret = HERE();
-	sopno len = finish - start;
-
-	assert(finish >= start);
-	if (len == 0)
-		return(ret);
-	enlarge(p, p->ssize + len);	/* this many unexpected additions */
-	assert(p->ssize >= p->slen + len);
-	(void) memcpy((char *)(p->strip + p->slen),
-		(char *)(p->strip + start), (size_t)len*sizeof(sop));
-	p->slen += len;
-	return(ret);
-}
-
-/*
- - doemit - emit a strip operator
- == static void doemit(struct parse *p, sop op, size_t opnd);
- *
- * It might seem better to implement this as a macro with a function as
- * hard-case backup, but it's just too big and messy unless there are
- * some changes to the data structures.  Maybe later.
- */
-static void
-doemit(p, op, opnd)
-struct parse *p;
-sop op;
-size_t opnd;
-{
-	/* avoid making error situations worse */
-	if (p->error != 0)
-		return;
-
-	/* deal with oversize operands ("can't happen", more or less) */
-	assert(opnd < 1<<OPSHIFT);
-
-	/* deal with undersized strip */
-	if (p->slen >= p->ssize)
-		enlarge(p, (p->ssize+1) / 2 * 3);	/* +50% */
-	assert(p->slen < p->ssize);
-
-	/* finally, it's all reduced to the easy case */
-	p->strip[p->slen++] = SOP(op, opnd);
-}
-
-/*
- - doinsert - insert a sop into the strip
- == static void doinsert(struct parse *p, sop op, size_t opnd, sopno pos);
- */
-static void
-doinsert(p, op, opnd, pos)
-struct parse *p;
-sop op;
-size_t opnd;
-sopno pos;
-{
-	sopno sn;
-	sop s;
-	int i;
-
-	/* avoid making error situations worse */
-	if (p->error != 0)
-		return;
-
-	sn = HERE();
-	EMIT(op, opnd);		/* do checks, ensure space */
-	assert(HERE() == sn+1);
-	s = p->strip[sn];
-
-	/* adjust paren pointers */
-	assert(pos > 0);
-	for (i = 1; i < NPAREN; i++) {
-		if (p->pbegin[i] >= pos) {
-			p->pbegin[i]++;
-		}
-		if (p->pend[i] >= pos) {
-			p->pend[i]++;
-		}
-	}
-
-	memmove((char *)&p->strip[pos+1], (char *)&p->strip[pos],
-						(HERE()-pos-1)*sizeof(sop));
-	p->strip[pos] = s;
-}
-
-/*
- - dofwd - complete a forward reference
- == static void dofwd(struct parse *p, sopno pos, sop value);
- */
-static void
-dofwd(p, pos, value)
-struct parse *p;
-sopno pos;
-sop value;
-{
-	/* avoid making error situations worse */
-	if (p->error != 0)
-		return;
-
-	assert(value < 1<<OPSHIFT);
-	p->strip[pos] = OP(p->strip[pos]) | value;
-}
-
-/*
- - enlarge - enlarge the strip
- == static void enlarge(struct parse *p, sopno size);
- */
-static void
-enlarge(p, size)
-struct parse *p;
-sopno size;
-{
-	sop *sp;
-
-	if (p->ssize >= size)
-		return;
-
-	sp = (sop *)realloc(p->strip, size*sizeof(sop));
-	if (sp == NULL) {
-		SETERROR(REG_ESPACE);
-		return;
-	}
-	p->strip = sp;
-	p->ssize = size;
-}
-
-/*
- - stripsnug - compact the strip
- == static void stripsnug(struct parse *p, struct re_guts *g);
- */
-static void
-stripsnug(p, g)
-struct parse *p;
-struct re_guts *g;
-{
-	g->nstates = p->slen;
-	g->strip = (sop *)realloc((char *)p->strip, p->slen * sizeof(sop));
-	if (g->strip == NULL) {
-		SETERROR(REG_ESPACE);
-		g->strip = p->strip;
-	}
-}
-
-/*
- - findmust - fill in must and mlen with longest mandatory literal string
- == static void findmust(struct parse *p, struct re_guts *g);
- *
- * This algorithm could do fancy things like analyzing the operands of |
- * for common subsequences.  Someday.  This code is simple and finds most
- * of the interesting cases.
- *
- * Note that must and mlen got initialized during setup.
- */
-static void
-findmust(p, g)
-struct parse *p;
-struct re_guts *g;
-{
-	sop *scan;
-	sop *start;
-	sop *newstart;
-	sopno newlen;
-	sop s;
-	char *cp;
-	sopno i;
-	int offset;
-	int cs, mccs;
-
-	/* avoid making error situations worse */
-	if (p->error != 0)
-		return;
-
-	/* Find out if we can handle OANYOF or not */
-	mccs = 0;
-	for (cs = 0; cs < g->ncsets; cs++)
-		if (g->sets[cs].multis != NULL)
-			mccs = 1;
-
-	/* find the longest OCHAR sequence in strip */
-	newlen = 0;
-	offset = 0;
-	g->moffset = 0;
-	scan = g->strip + 1;
-	do {
-		s = *scan++;
-		switch (OP(s)) {
-		case OCHAR:		/* sequence member */
-			if (newlen == 0)		/* new sequence */
-				newstart = scan - 1;
-			newlen++;
-			break;
-		case OPLUS_:		/* things that don't break one */
-		case OLPAREN:
-		case ORPAREN:
-			break;
-		case OQUEST_:		/* things that must be skipped */
-		case OCH_:
-			offset = altoffset(scan, offset, mccs);
-			scan--;
-			do {
-				scan += OPND(s);
-				s = *scan;
-				/* assert() interferes w debug printouts */
-				if (OP(s) != O_QUEST && OP(s) != O_CH &&
-							OP(s) != OOR2) {
-					g->iflags |= BAD;
-					return;
-				}
-			} while (OP(s) != O_QUEST && OP(s) != O_CH);
-			/* fallthrough */
-		case OBOW:		/* things that break a sequence */
-		case OEOW:
-		case OBOL:
-		case OEOL:
-		case O_QUEST:
-		case O_CH:
-		case OEND:
-			if (newlen > g->mlen) {		/* ends one */
-				start = newstart;
-				g->mlen = newlen;
-				if (offset > -1) {
-					g->moffset += offset;
-					offset = newlen;
-				} else
-					g->moffset = offset;
-			} else {
-				if (offset > -1)
-					offset += newlen;
-			}
-			newlen = 0;
-			break;
-		case OANY:
-			if (newlen > g->mlen) {		/* ends one */
-				start = newstart;
-				g->mlen = newlen;
-				if (offset > -1) {
-					g->moffset += offset;
-					offset = newlen;
-				} else
-					g->moffset = offset;
-			} else {
-				if (offset > -1)
-					offset += newlen;
-			}
-			if (offset > -1)
-				offset++;
-			newlen = 0;
-			break;
-		case OANYOF:		/* may or may not invalidate offset */
-			/* First, everything as OANY */
-			if (newlen > g->mlen) {		/* ends one */
-				start = newstart;
-				g->mlen = newlen;
-				if (offset > -1) {
-					g->moffset += offset;
-					offset = newlen;
-				} else
-					g->moffset = offset;
-			} else {
-				if (offset > -1)
-					offset += newlen;
-			}
-			if (offset > -1)
-				offset++;
-			newlen = 0;
-			/* And, now, if we found out we can't deal with
-			 * it, make offset = -1.
-			 */
-			if (mccs)
-				offset = -1;
-			break;
-		default:
-			/* Anything here makes it impossible or too hard
-			 * to calculate the offset -- so we give up;
-			 * save the last known good offset, in case the
-			 * must sequence doesn't occur later.
-			 */
-			if (newlen > g->mlen) {		/* ends one */
-				start = newstart;
-				g->mlen = newlen;
-				if (offset > -1)
-					g->moffset += offset;
-				else
-					g->moffset = offset;
-			}
-			offset = -1;
-			newlen = 0;
-			break;
-		}
-	} while (OP(s) != OEND);
-
-	if (g->mlen == 0) {		/* there isn't one */
-		g->moffset = -1;
-		return;
-	}
-
-	/* turn it into a character string */
-	g->must = malloc((size_t)g->mlen + 1);
-	if (g->must == NULL) {		/* argh; just forget it */
-		g->mlen = 0;
-		g->moffset = -1;
-		return;
-	}
-	cp = g->must;
-	scan = start;
-	for (i = g->mlen; i > 0; i--) {
-		while (OP(s = *scan++) != OCHAR)
-			continue;
-		assert(cp < g->must + g->mlen);
-		*cp++ = (char)OPND(s);
-	}
-	assert(cp == g->must + g->mlen);
-	*cp++ = '\0';		/* just on general principles */
-}
-
-/*
- - altoffset - choose biggest offset among multiple choices
- == static int altoffset(sop *scan, int offset, int mccs);
- *
- * Compute, recursively if necessary, the largest offset among multiple
- * re paths.
- */
-static int
-altoffset(scan, offset, mccs)
-sop *scan;
-int offset;
-int mccs;
-{
-	int largest;
-	int try;
-	sop s;
-
-	/* If we gave up already on offsets, return */
-	if (offset == -1)
-		return -1;
-
-	largest = 0;
-	try = 0;
-	s = *scan++;
-	while (OP(s) != O_QUEST && OP(s) != O_CH) {
-		switch (OP(s)) {
-		case OOR1:
-			if (try > largest)
-				largest = try;
-			try = 0;
-			break;
-		case OQUEST_:
-		case OCH_:
-			try = altoffset(scan, try, mccs);
-			if (try == -1)
-				return -1;
-			scan--;
-			do {
-				scan += OPND(s);
-				s = *scan;
-				if (OP(s) != O_QUEST && OP(s) != O_CH &&
-							OP(s) != OOR2)
-					return -1;
-			} while (OP(s) != O_QUEST && OP(s) != O_CH);
-			/* We must skip to the next position, or we'll
-			 * leave altoffset() too early.
-			 */
-			scan++;
-			break;
-		case OANYOF:
-			if (mccs)
-				return -1;
-		case OCHAR:
-		case OANY:
-			try++;
-		case OBOW:
-		case OEOW:
-		case OLPAREN:
-		case ORPAREN:
-		case OOR2:
-			break;
-		default:
-			try = -1;
-			break;
-		}
-		if (try == -1)
-			return -1;
-		s = *scan++;
-	}
-
-	if (try > largest)
-		largest = try;
-
-	return largest+offset;
-}
-
-/*
- - computejumps - compute char jumps for BM scan
- == static void computejumps(struct parse *p, struct re_guts *g);
- *
- * This algorithm assumes g->must exists and is has size greater than
- * zero. It's based on the algorithm found on Computer Algorithms by
- * Sara Baase.
- *
- * A char jump is the number of characters one needs to jump based on
- * the value of the character from the text that was mismatched.
- */
-static void
-computejumps(p, g)
-struct parse *p;
-struct re_guts *g;
-{
-	int ch;
-	int mindex;
-
-	/* Avoid making errors worse */
-	if (p->error != 0)
-		return;
-
-	g->charjump = (int*) malloc((NC + 1) * sizeof(int));
-	if (g->charjump == NULL)	/* Not a fatal error */
-		return;
-	/* Adjust for signed chars, if necessary */
-	g->charjump = &g->charjump[-(CHAR_MIN)];
-
-	/* If the character does not exist in the pattern, the jump
-	 * is equal to the number of characters in the pattern.
-	 */
-	for (ch = CHAR_MIN; ch < (CHAR_MAX + 1); ch++)
-		g->charjump[ch] = g->mlen;
-
-	/* If the character does exist, compute the jump that would
-	 * take us to the last character in the pattern equal to it
-	 * (notice that we match right to left, so that last character
-	 * is the first one that would be matched).
-	 */
-	for (mindex = 0; mindex < g->mlen; mindex++)
-		g->charjump[g->must[mindex]] = g->mlen - mindex - 1;
-}
-
-/*
- - computematchjumps - compute match jumps for BM scan
- == static void computematchjumps(struct parse *p, struct re_guts *g);
- *
- * This algorithm assumes g->must exists and is has size greater than
- * zero. It's based on the algorithm found on Computer Algorithms by
- * Sara Baase.
- *
- * A match jump is the number of characters one needs to advance based
- * on the already-matched suffix.
- * Notice that all values here are minus (g->mlen-1), because of the way
- * the search algorithm works.
- */
-static void
-computematchjumps(p, g)
-struct parse *p;
-struct re_guts *g;
-{
-	int mindex;		/* General "must" iterator */
-	int suffix;		/* Keeps track of matching suffix */
-	int ssuffix;		/* Keeps track of suffixes' suffix */
-	int* pmatches;		/* pmatches[k] points to the next i
-				 * such that i+1...mlen is a substring
-				 * of k+1...k+mlen-i-1
-				 */
-
-	/* Avoid making errors worse */
-	if (p->error != 0)
-		return;
-
-	pmatches = (int*) malloc(g->mlen * sizeof(unsigned int));
-	if (pmatches == NULL) {
-		g->matchjump = NULL;
-		return;
-	}
-
-	g->matchjump = (int*) malloc(g->mlen * sizeof(unsigned int));
-	if (g->matchjump == NULL)	/* Not a fatal error */
-		return;
-
-	/* Set maximum possible jump for each character in the pattern */
-	for (mindex = 0; mindex < g->mlen; mindex++)
-		g->matchjump[mindex] = 2*g->mlen - mindex - 1;
-
-	/* Compute pmatches[] */
-	for (mindex = g->mlen - 1, suffix = g->mlen; mindex >= 0;
-	    mindex--, suffix--) {
-		pmatches[mindex] = suffix;
-
-		/* If a mismatch is found, interrupting the substring,
-		 * compute the matchjump for that position. If no
-		 * mismatch is found, then a text substring mismatched
-		 * against the suffix will also mismatch against the
-		 * substring.
-		 */
-		while (suffix < g->mlen
-		    && g->must[mindex] != g->must[suffix]) {
-			g->matchjump[suffix] = MIN(g->matchjump[suffix],
-			    g->mlen - mindex - 1);
-			suffix = pmatches[suffix];
-		}
-	}
-
-	/* Compute the matchjump up to the last substring found to jump
-	 * to the beginning of the largest must pattern prefix matching
-	 * it's own suffix.
-	 */
-	for (mindex = 0; mindex <= suffix; mindex++)
-		g->matchjump[mindex] = MIN(g->matchjump[mindex],
-		    g->mlen + suffix - mindex);
-
-        ssuffix = pmatches[suffix];
-        while (suffix < g->mlen) {
-                while (suffix <= ssuffix && suffix < g->mlen) {
-                        g->matchjump[suffix] = MIN(g->matchjump[suffix],
-			    g->mlen + ssuffix - suffix);
-                        suffix++;
-                }
-		if (suffix < g->mlen)
-                	ssuffix = pmatches[ssuffix];
-        }
-
-	free(pmatches);
-}
-
-/*
- - pluscount - count + nesting
- == static sopno pluscount(struct parse *p, struct re_guts *g);
- */
-static sopno			/* nesting depth */
-pluscount(p, g)
-struct parse *p;
-struct re_guts *g;
-{
-	sop *scan;
-	sop s;
-	sopno plusnest = 0;
-	sopno maxnest = 0;
-
-	if (p->error != 0)
-		return(0);	/* there may not be an OEND */
-
-	scan = g->strip + 1;
-	do {
-		s = *scan++;
-		switch (OP(s)) {
-		case OPLUS_:
-			plusnest++;
-			break;
-		case O_PLUS:
-			if (plusnest > maxnest)
-				maxnest = plusnest;
-			plusnest--;
-			break;
-		}
-	} while (OP(s) != OEND);
-	if (plusnest != 0)
-		g->iflags |= BAD;
-	return(maxnest);
-}
diff -ruN rexxre/regex/regerror.c rexxre-patch/regex/regerror.c
--- rexxre/regex/regerror.c	2002-03-21 17:48:00.000000000 +1300
+++ rexxre-patch/regex/regerror.c	1970-01-01 13:00:00.000000000 +1300
@@ -1,179 +0,0 @@
-/*-
- * Copyright (c) 1992, 1993, 1994 Henry Spencer.
- * Copyright (c) 1992, 1993, 1994
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Henry Spencer.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)regerror.c	8.4 (Berkeley) 3/20/94
- */
-
-#if defined(LIBC_SCCS) && !defined(lint)
-static char sccsid[] = "@(#)regerror.c	8.4 (Berkeley) 3/20/94";
-#endif /* LIBC_SCCS and not lint */
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD$");
-
-#include <sys/types.h>
-#include <stdio.h>
-#include <string.h>
-#include <limits.h>
-#include <stdlib.h>
-#include <regex.h>
-
-#include "utils.h"
-
-/* ========= begin header generated by ./mkh ========= */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* === regerror.c === */
-static char *regatoi(const regex_t *preg, char *localbuf);
-
-#ifdef __cplusplus
-}
-#endif
-/* ========= end header generated by ./mkh ========= */
-/*
- = #define	REG_NOMATCH	 1
- = #define	REG_BADPAT	 2
- = #define	REG_ECOLLATE	 3
- = #define	REG_ECTYPE	 4
- = #define	REG_EESCAPE	 5
- = #define	REG_ESUBREG	 6
- = #define	REG_EBRACK	 7
- = #define	REG_EPAREN	 8
- = #define	REG_EBRACE	 9
- = #define	REG_BADBR	10
- = #define	REG_ERANGE	11
- = #define	REG_ESPACE	12
- = #define	REG_BADRPT	13
- = #define	REG_EMPTY	14
- = #define	REG_ASSERT	15
- = #define	REG_INVARG	16
- = #define	REG_ATOI	255	// convert name to number (!)
- = #define	REG_ITOA	0400	// convert number to name (!)
- */
-static struct rerr {
-	int code;
-	char *name;
-	char *explain;
-} rerrs[] = {
-	{REG_NOMATCH,	"REG_NOMATCH",	"regexec() failed to match"},
-	{REG_BADPAT,	"REG_BADPAT",	"invalid regular expression"},
-	{REG_ECOLLATE,	"REG_ECOLLATE",	"invalid collating element"},
-	{REG_ECTYPE,	"REG_ECTYPE",	"invalid character class"},
-	{REG_EESCAPE,	"REG_EESCAPE",	"trailing backslash (\\)"},
-	{REG_ESUBREG,	"REG_ESUBREG",	"invalid backreference number"},
-	{REG_EBRACK,	"REG_EBRACK",	"brackets ([ ]) not balanced"},
-	{REG_EPAREN,	"REG_EPAREN",	"parentheses not balanced"},
-	{REG_EBRACE,	"REG_EBRACE",	"braces not balanced"},
-	{REG_BADBR,	"REG_BADBR",	"invalid repetition count(s)"},
-	{REG_ERANGE,	"REG_ERANGE",	"invalid character range"},
-	{REG_ESPACE,	"REG_ESPACE",	"out of memory"},
-	{REG_BADRPT,	"REG_BADRPT",	"repetition-operator operand invalid"},
-	{REG_EMPTY,	"REG_EMPTY",	"empty (sub)expression"},
-	{REG_ASSERT,	"REG_ASSERT",	"\"can't happen\" -- you found a bug"},
-	{REG_INVARG,	"REG_INVARG",	"invalid argument to regex routine"},
-	{0,		"",		"*** unknown regexp error code ***"}
-};
-
-/*
- - regerror - the interface to error numbers
- = extern size_t regerror(int, const regex_t *, char *, size_t);
- */
-/* ARGSUSED */
-size_t
-regerror(errcode, preg, errbuf, errbuf_size)
-int errcode;
-const regex_t *preg;
-char *errbuf;
-size_t errbuf_size;
-{
-	struct rerr *r;
-	size_t len;
-	int target = errcode &~ REG_ITOA;
-	char *s;
-	char convbuf[50];
-
-	if (errcode == REG_ATOI)
-		s = regatoi(preg, convbuf);
-	else {
-		for (r = rerrs; r->code != 0; r++)
-			if (r->code == target)
-				break;
-
-		if (errcode&REG_ITOA) {
-			if (r->code != 0)
-				(void) strcpy(convbuf, r->name);
-			else
-				sprintf(convbuf, "REG_0x%x", target);
-			assert(strlen(convbuf) < sizeof(convbuf));
-			s = convbuf;
-		} else
-			s = r->explain;
-	}
-
-	len = strlen(s) + 1;
-	if (errbuf_size > 0) {
-		if (errbuf_size > len)
-			(void) strcpy(errbuf, s);
-		else {
-			(void) strncpy(errbuf, s, errbuf_size-1);
-			errbuf[errbuf_size-1] = '\0';
-		}
-	}
-
-	return(len);
-}
-
-/*
- - regatoi - internal routine to implement REG_ATOI
- == static char *regatoi(const regex_t *preg, char *localbuf);
- */
-static char *
-regatoi(preg, localbuf)
-const regex_t *preg;
-char *localbuf;
-{
-	struct rerr *r;
-
-	for (r = rerrs; r->code != 0; r++)
-		if (strcmp(r->name, preg->re_endp) == 0)
-			break;
-	if (r->code == 0)
-		return("0");
-
-	sprintf(localbuf, "%d", r->code);
-	return(localbuf);
-}
diff -ruN rexxre/regex/regex.h rexxre-patch/regex/regex.h
--- rexxre/regex/regex.h	2002-03-23 12:24:54.000000000 +1300
+++ rexxre-patch/regex/regex.h	1970-01-01 13:00:00.000000000 +1300
@@ -1,106 +0,0 @@
-/*-
- * Copyright (c) 1992 Henry Spencer.
- * Copyright (c) 1992, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Henry Spencer of the University of Toronto.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)regex.h	8.2 (Berkeley) 1/3/94
- * $FreeBSD$
- */
-
-#ifndef _REGEX_H_
-#define	_REGEX_H_
-
-#include <sys/cdefs.h>
-
-/* types */
-typedef off_t regoff_t;
-
-typedef struct {
-	int re_magic;
-	size_t re_nsub;		/* number of parenthesized subexpressions */
-	__const char *re_endp;	/* end pointer for REG_PEND */
-	struct re_guts *re_g;	/* none of your business :-) */
-} regex_t;
-
-typedef struct {
-	regoff_t rm_so;		/* start of match */
-	regoff_t rm_eo;		/* end of match */
-} regmatch_t;
-
-/* regcomp() flags */
-#define	REG_BASIC	0000
-#define	REG_EXTENDED	0001
-#define	REG_ICASE	0002
-#define	REG_NOSUB	0004
-#define	REG_NEWLINE	0010
-#define	REG_NOSPEC	0020
-#define	REG_PEND	0040
-#define	REG_DUMP	0200
-
-/* regerror() flags */
-#define	REG_NOMATCH	 1
-#define	REG_BADPAT	 2
-#define	REG_ECOLLATE	 3
-#define	REG_ECTYPE	 4
-#define	REG_EESCAPE	 5
-#define	REG_ESUBREG	 6
-#define	REG_EBRACK	 7
-#define	REG_EPAREN	 8
-#define	REG_EBRACE	 9
-#define	REG_BADBR	10
-#define	REG_ERANGE	11
-#define	REG_ESPACE	12
-#define	REG_BADRPT	13
-#define	REG_EMPTY	14
-#define	REG_ASSERT	15
-#define	REG_INVARG	16
-#define	REG_ATOI	255	/* convert name to number (!) */
-#define	REG_ITOA	0400	/* convert number to name (!) */
-
-/* regexec() flags */
-#define	REG_NOTBOL	00001
-#define	REG_NOTEOL	00002
-#define	REG_STARTEND	00004
-#define	REG_TRACE	00400	/* tracing of execution */
-#define	REG_LARGE	01000	/* force large representation */
-#define	REG_BACKR	02000	/* force use of backref code */
-
-__BEGIN_DECLS
-int	regcomp(regex_t *, const char *, int);
-size_t	regerror(int, const regex_t *, char *, size_t);
-int	regexec(const regex_t *, const char *, size_t, regmatch_t [], int);
-void	regfree(regex_t *);
-__END_DECLS
-
-#endif /* !_REGEX_H_ */
diff -ruN rexxre/regex/regex2.h rexxre-patch/regex/regex2.h
--- rexxre/regex/regex2.h	2002-03-22 18:41:56.000000000 +1300
+++ rexxre-patch/regex/regex2.h	1970-01-01 13:00:00.000000000 +1300
@@ -1,177 +0,0 @@
-/*-
- * Copyright (c) 1992, 1993, 1994 Henry Spencer.
- * Copyright (c) 1992, 1993, 1994
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Henry Spencer.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)regex2.h	8.4 (Berkeley) 3/20/94
- * $FreeBSD$
- */
-
-/*
- * First, the stuff that ends up in the outside-world include file
- = typedef off_t regoff_t;
- = typedef struct {
- = 	int re_magic;
- = 	size_t re_nsub;		// number of parenthesized subexpressions
- = 	const char *re_endp;	// end pointer for REG_PEND
- = 	struct re_guts *re_g;	// none of your business :-)
- = } regex_t;
- = typedef struct {
- = 	regoff_t rm_so;		// start of match
- = 	regoff_t rm_eo;		// end of match
- = } regmatch_t;
- */
-/*
- * internals of regex_t
- */
-#define	MAGIC1	((('r'^0200)<<8) | 'e')
-
-/*
- * The internal representation is a *strip*, a sequence of
- * operators ending with an endmarker.  (Some terminology etc. is a
- * historical relic of earlier versions which used multiple strips.)
- * Certain oddities in the representation are there to permit running
- * the machinery backwards; in particular, any deviation from sequential
- * flow must be marked at both its source and its destination.  Some
- * fine points:
- *
- * - OPLUS_ and O_PLUS are *inside* the loop they create.
- * - OQUEST_ and O_QUEST are *outside* the bypass they create.
- * - OCH_ and O_CH are *outside* the multi-way branch they create, while
- *   OOR1 and OOR2 are respectively the end and the beginning of one of
- *   the branches.  Note that there is an implicit OOR2 following OCH_
- *   and an implicit OOR1 preceding O_CH.
- *
- * In state representations, an operator's bit is on to signify a state
- * immediately *preceding* "execution" of that operator.
- */
-typedef unsigned long sop;	/* strip operator */
-typedef long sopno;
-#define	OPRMASK	0xf8000000L
-#define	OPDMASK	0x07ffffffL
-#define	OPSHIFT	((unsigned)27)
-#define	OP(n)	((n)&OPRMASK)
-#define	OPND(n)	((n)&OPDMASK)
-#define	SOP(op, opnd)	((op)|(opnd))
-/* operators			   meaning	operand			*/
-/*						(back, fwd are offsets)	*/
-#define	OEND	(1L<<OPSHIFT)	/* endmarker	-			*/
-#define	OCHAR	(2L<<OPSHIFT)	/* character	unsigned char		*/
-#define	OBOL	(3L<<OPSHIFT)	/* left anchor	-			*/
-#define	OEOL	(4L<<OPSHIFT)	/* right anchor	-			*/
-#define	OANY	(5L<<OPSHIFT)	/* .		-			*/
-#define	OANYOF	(6L<<OPSHIFT)	/* [...]	set number		*/
-#define	OBACK_	(7L<<OPSHIFT)	/* begin \d	paren number		*/
-#define	O_BACK	(8L<<OPSHIFT)	/* end \d	paren number		*/
-#define	OPLUS_	(9L<<OPSHIFT)	/* + prefix	fwd to suffix		*/
-#define	O_PLUS	(10L<<OPSHIFT)	/* + suffix	back to prefix		*/
-#define	OQUEST_	(11L<<OPSHIFT)	/* ? prefix	fwd to suffix		*/
-#define	O_QUEST	(12L<<OPSHIFT)	/* ? suffix	back to prefix		*/
-#define	OLPAREN	(13L<<OPSHIFT)	/* (		fwd to )		*/
-#define	ORPAREN	(14L<<OPSHIFT)	/* )		back to (		*/
-#define	OCH_	(15L<<OPSHIFT)	/* begin choice	fwd to OOR2		*/
-#define	OOR1	(16L<<OPSHIFT)	/* | pt. 1	back to OOR1 or OCH_	*/
-#define	OOR2	(17L<<OPSHIFT)	/* | pt. 2	fwd to OOR2 or O_CH	*/
-#define	O_CH	(18L<<OPSHIFT)	/* end choice	back to OOR1		*/
-#define	OBOW	(19L<<OPSHIFT)	/* begin word	-			*/
-#define	OEOW	(20L<<OPSHIFT)	/* end word	-			*/
-
-/*
- * Structure for [] character-set representation.  Character sets are
- * done as bit vectors, grouped 8 to a byte vector for compactness.
- * The individual set therefore has both a pointer to the byte vector
- * and a mask to pick out the relevant bit of each byte.  A hash code
- * simplifies testing whether two sets could be identical.
- *
- * This will get trickier for multicharacter collating elements.  As
- * preliminary hooks for dealing with such things, we also carry along
- * a string of multi-character elements, and decide the size of the
- * vectors at run time.
- */
-typedef struct {
-	uch *ptr;		/* -> uch [csetsize] */
-	uch mask;		/* bit within array */
-	short hash;             /* hash code */
-	size_t smultis;
-	char *multis;		/* -> char[smulti]  ab\0cd\0ef\0\0 */
-} cset;
-/* note that CHadd and CHsub are unsafe, and CHIN doesn't yield 0/1 */
-#define CHadd(cs, c)    ((cs)->ptr[(uch)(c)] |= (cs)->mask, (cs)->hash += (uch)(c))
-#define CHsub(cs, c)    ((cs)->ptr[(uch)(c)] &= ~(cs)->mask, (cs)->hash -= (uch)(c))
-#define	CHIN(cs, c)	((cs)->ptr[(uch)(c)] & (cs)->mask)
-#define	MCadd(p, cs, cp)	mcadd(p, cs, cp)	/* regcomp() internal fns */
-#define	MCsub(p, cs, cp)	mcsub(p, cs, cp)
-#define	MCin(p, cs, cp)	mcin(p, cs, cp)
-
-/* stuff for character categories */
-typedef unsigned char cat_t;
-
-/*
- * main compiled-expression structure
- */
-struct re_guts {
-	int magic;
-#		define	MAGIC2	((('R'^0200)<<8)|'E')
-	sop *strip;		/* malloced area for strip */
-	int csetsize;		/* number of bits in a cset vector */
-	int ncsets;		/* number of csets in use */
-	cset *sets;		/* -> cset [ncsets] */
-	uch *setbits;		/* -> uch[csetsize][ncsets/CHAR_BIT] */
-	int cflags;		/* copy of regcomp() cflags argument */
-	sopno nstates;		/* = number of sops */
-	sopno firststate;	/* the initial OEND (normally 0) */
-	sopno laststate;	/* the final OEND */
-	int iflags;		/* internal flags */
-#		define	USEBOL	01	/* used ^ */
-#		define	USEEOL	02	/* used $ */
-#		define	BAD	04	/* something wrong */
-	int nbol;		/* number of ^ used */
-	int neol;		/* number of $ used */
-	int ncategories;	/* how many character categories */
-	cat_t *categories;	/* ->catspace[-CHAR_MIN] */
-	char *must;		/* match must contain this string */
-	int moffset;		/* latest point at which must may be located */
-	int *charjump;		/* Boyer-Moore char jump table */
-	int *matchjump;		/* Boyer-Moore match jump table */
-	int mlen;		/* length of must */
-	size_t nsub;		/* copy of re_nsub */
-	int backrefs;		/* does it use back references? */
-	sopno nplus;		/* how deep does it nest +s? */
-	/* catspace must be last */
-	cat_t catspace[1];	/* actually [NC] */
-};
-
-/* misc utilities */
-#define	OUT	(CHAR_MAX+1)	/* a non-character value */
-#define ISWORD(c)       (isalnum((uch)(c)) || (c) == '_')
diff -ruN rexxre/regex/regexec.c rexxre-patch/regex/regexec.c
--- rexxre/regex/regexec.c	2002-03-21 13:41:52.000000000 +1300
+++ rexxre-patch/regex/regexec.c	1970-01-01 13:00:00.000000000 +1300
@@ -1,183 +0,0 @@
-/*-
- * Copyright (c) 1992, 1993, 1994 Henry Spencer.
- * Copyright (c) 1992, 1993, 1994
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Henry Spencer.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)regexec.c	8.3 (Berkeley) 3/20/94
- */
-
-#if defined(LIBC_SCCS) && !defined(lint)
-static char sccsid[] = "@(#)regexec.c	8.3 (Berkeley) 3/20/94";
-#endif /* LIBC_SCCS and not lint */
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD$");
-
-/*
- * the outer shell of regexec()
- *
- * This file includes engine.c *twice*, after muchos fiddling with the
- * macros that code uses.  This lets the same code operate on two different
- * representations for state sets.
- */
-#include <sys/types.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <limits.h>
-#include <ctype.h>
-#include <regex.h>
-
-#include "utils.h"
-#include "regex2.h"
-
-static int nope = 0;		/* for use in asserts; shuts lint up */
-
-/* macros for manipulating states, small version */
-#define	states	long
-#define	states1	states		/* for later use in regexec() decision */
-#define	CLEAR(v)	((v) = 0)
-#define	SET0(v, n)	((v) &= ~((unsigned long)1 << (n)))
-#define	SET1(v, n)	((v) |= (unsigned long)1 << (n))
-#define	ISSET(v, n)	(((v) & ((unsigned long)1 << (n))) != 0)
-#define	ASSIGN(d, s)	((d) = (s))
-#define	EQ(a, b)	((a) == (b))
-#define	STATEVARS	long dummy	/* dummy version */
-#define	STATESETUP(m, n)	/* nothing */
-#define	STATETEARDOWN(m)	/* nothing */
-#define	SETUP(v)	((v) = 0)
-#define	onestate	long
-#define	INIT(o, n)	((o) = (unsigned long)1 << (n))
-#define	INC(o)	((o) <<= 1)
-#define	ISSTATEIN(v, o)	(((v) & (o)) != 0)
-/* some abbreviations; note that some of these know variable names! */
-/* do "if I'm here, I can also be there" etc without branches */
-#define	FWD(dst, src, n)	((dst) |= ((unsigned long)(src)&(here)) << (n))
-#define	BACK(dst, src, n)	((dst) |= ((unsigned long)(src)&(here)) >> (n))
-#define	ISSETBACK(v, n)	(((v) & ((unsigned long)here >> (n))) != 0)
-/* function names */
-#define SNAMES			/* engine.c looks after details */
-
-#include "engine.c"
-
-/* now undo things */
-#undef	states
-#undef	CLEAR
-#undef	SET0
-#undef	SET1
-#undef	ISSET
-#undef	ASSIGN
-#undef	EQ
-#undef	STATEVARS
-#undef	STATESETUP
-#undef	STATETEARDOWN
-#undef	SETUP
-#undef	onestate
-#undef	INIT
-#undef	INC
-#undef	ISSTATEIN
-#undef	FWD
-#undef	BACK
-#undef	ISSETBACK
-#undef	SNAMES
-
-/* macros for manipulating states, large version */
-#define	states	char *
-#define	CLEAR(v)	memset(v, 0, m->g->nstates)
-#define	SET0(v, n)	((v)[n] = 0)
-#define	SET1(v, n)	((v)[n] = 1)
-#define	ISSET(v, n)	((v)[n])
-#define	ASSIGN(d, s)	memcpy(d, s, m->g->nstates)
-#define	EQ(a, b)	(memcmp(a, b, m->g->nstates) == 0)
-#define	STATEVARS	long vn; char *space
-#define	STATESETUP(m, nv)	{ (m)->space = malloc((nv)*(m)->g->nstates); \
-				if ((m)->space == NULL) return(REG_ESPACE); \
-				(m)->vn = 0; }
-#define	STATETEARDOWN(m)	{ free((m)->space); }
-#define	SETUP(v)	((v) = &m->space[m->vn++ * m->g->nstates])
-#define	onestate	long
-#define	INIT(o, n)	((o) = (n))
-#define	INC(o)	((o)++)
-#define	ISSTATEIN(v, o)	((v)[o])
-/* some abbreviations; note that some of these know variable names! */
-/* do "if I'm here, I can also be there" etc without branches */
-#define	FWD(dst, src, n)	((dst)[here+(n)] |= (src)[here])
-#define	BACK(dst, src, n)	((dst)[here-(n)] |= (src)[here])
-#define	ISSETBACK(v, n)	((v)[here - (n)])
-/* function names */
-#define	LNAMES			/* flag */
-
-#include "engine.c"
-
-/*
- - regexec - interface for matching
- = extern int regexec(const regex_t *, const char *, size_t, \
- =					regmatch_t [], int);
- = #define	REG_NOTBOL	00001
- = #define	REG_NOTEOL	00002
- = #define	REG_STARTEND	00004
- = #define	REG_TRACE	00400	// tracing of execution
- = #define	REG_LARGE	01000	// force large representation
- = #define	REG_BACKR	02000	// force use of backref code
- *
- * We put this here so we can exploit knowledge of the state representation
- * when choosing which matcher to call.  Also, by this point the matchers
- * have been prototyped.
- */
-int				/* 0 success, REG_NOMATCH failure */
-regexec(preg, string, nmatch, pmatch, eflags)
-const regex_t *preg;
-const char *string;
-size_t nmatch;
-regmatch_t pmatch[];
-int eflags;
-{
-	struct re_guts *g = preg->re_g;
-#ifdef REDEBUG
-#	define	GOODFLAGS(f)	(f)
-#else
-#	define	GOODFLAGS(f)	((f)&(REG_NOTBOL|REG_NOTEOL|REG_STARTEND))
-#endif
-
-	if (preg->re_magic != MAGIC1 || g->magic != MAGIC2)
-		return(REG_BADPAT);
-	assert(!(g->iflags&BAD));
-	if (g->iflags&BAD)		/* backstop for no-debug case */
-		return(REG_BADPAT);
-	eflags = GOODFLAGS(eflags);
-
-	if (g->nstates <= CHAR_BIT*sizeof(states1) && !(eflags&REG_LARGE))
-		return(smatcher(g, (char *)string, nmatch, pmatch, eflags));
-	else
-		return(lmatcher(g, (char *)string, nmatch, pmatch, eflags));
-}
diff -ruN rexxre/regex/regfree.c rexxre-patch/regex/regfree.c
--- rexxre/regex/regfree.c	2002-03-22 16:52:48.000000000 +1300
+++ rexxre-patch/regex/regfree.c	1970-01-01 13:00:00.000000000 +1300
@@ -1,87 +0,0 @@
-/*-
- * Copyright (c) 1992, 1993, 1994 Henry Spencer.
- * Copyright (c) 1992, 1993, 1994
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Henry Spencer.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)regfree.c	8.3 (Berkeley) 3/20/94
- */
-
-#if defined(LIBC_SCCS) && !defined(lint)
-static char sccsid[] = "@(#)regfree.c	8.3 (Berkeley) 3/20/94";
-#endif /* LIBC_SCCS and not lint */
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD$");
-
-#include <sys/types.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <limits.h>
-#include <regex.h>
-
-#include "utils.h"
-#include "regex2.h"
-
-/*
- - regfree - free everything
- = extern void regfree(regex_t *);
- */
-void
-regfree(preg)
-regex_t *preg;
-{
-	struct re_guts *g;
-
-	if (preg->re_magic != MAGIC1)	/* oops */
-		return;			/* nice to complain, but hard */
-
-	g = preg->re_g;
-	if (g == NULL || g->magic != MAGIC2)	/* oops again */
-		return;
-	preg->re_magic = 0;		/* mark it invalid */
-	g->magic = 0;			/* mark it invalid */
-
-	if (g->strip != NULL)
-		free((char *)g->strip);
-	if (g->sets != NULL)
-		free((char *)g->sets);
-	if (g->setbits != NULL)
-		free((char *)g->setbits);
-	if (g->must != NULL)
-		free(g->must);
-	if (g->charjump != NULL)
-		free(&g->charjump[CHAR_MIN]);
-	if (g->matchjump != NULL)
-		free(g->matchjump);
-	free((char *)g);
-}
diff -ruN rexxre/regex/sys/cdefs.h rexxre-patch/regex/sys/cdefs.h
--- rexxre/regex/sys/cdefs.h	2003-04-29 10:40:16.000000000 +1200
+++ rexxre-patch/regex/sys/cdefs.h	1970-01-01 13:00:00.000000000 +1300
@@ -1,11 +0,0 @@
-#ifndef _SYS_CDEFS_H
-#define _SYS_CDEFS_H
-#define __P(x) x
-#define __FBSDID(x)
-#define __BEGIN_DECLS
-#define __END_DECLS
-#define _POSIX2_RE_DUP_MAX 255
-typedef unsigned char u_char;
-#define __const const
-
-#endif
diff -ruN rexxre/regex/utils.h rexxre-patch/regex/utils.h
--- rexxre/regex/utils.h	2002-03-22 18:41:56.000000000 +1300
+++ rexxre-patch/regex/utils.h	1970-01-01 13:00:00.000000000 +1300
@@ -1,58 +0,0 @@
-/*-
- * Copyright (c) 1992, 1993, 1994 Henry Spencer.
- * Copyright (c) 1992, 1993, 1994
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Henry Spencer.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)utils.h	8.3 (Berkeley) 3/20/94
- * $FreeBSD$
- */
-
-/* utility definitions */
-#define	DUPMAX		_POSIX2_RE_DUP_MAX	/* xxx is this right? */
-#define	INFINITY	(DUPMAX + 1)
-#define	NC		(CHAR_MAX - CHAR_MIN + 1)
-typedef unsigned char uch;
-
-/* switch off assertions (if not already off) if no REDEBUG */
-#ifndef REDEBUG
-#ifndef NDEBUG
-#define	NDEBUG	/* no assertions please */
-#endif
-#endif
-#include <assert.h>
-
-/* for old systems with bcopy() but no memmove() */
-#ifdef USEBCOPY
-#define	memmove(d, s, c)	bcopy(s, d, c)
-#endif
diff -ruN rexxre/retest.rex rexxre-patch/retest.rex
--- rexxre/retest.rex	2003-05-01 10:50:26.000000000 +1200
+++ rexxre-patch/retest.rex	1970-01-01 13:00:00.000000000 +1300
@@ -1,499 +0,0 @@
-/* RexxRE test suite.
- *
- * In contrast to, say, the RegUtil test suite, if this reports failure,
- * there's something wrong.
- *
- * Copyright 2003, Patrick TJ McPhee
- * Distributed under the Mozilla Public Licence.
- * $Header: C:/ptjm/rexx/rexxre/RCS/retest.rex 1.6 2003/05/01 15:50:26 ptjm Rel $
- */
-
-rcc = rxfuncquery('reloadfuncs')
-
-if rcc then do
-   rcc = rxfuncadd('reloadfuncs', 'rexxre', 'reloadfuncs')
-   if rcc then fail('load' rxfuncerrmsg())
-   end
-
-call reloadfuncs
-
-say '****' parse tests
-
-rcc = reparse('[a-z][a-z]*', 'noodles are poodles', 'v', 'n', 'a', 'p', 'd', 'x')
-
-test = 'parse with v flag'
-if \rcc then fail(test)
-if n \= 'noodles' then fail(test', first variable' n)
-if a \= 'are' then fail(test', second variable' a)
-if p \= 'poodles' then fail(test', third variable' p)
-if d \= '' then fail(test', extra variable' d)
-if x \= '' then fail(test', last variable' x)
-say 'pass' test
-
-rcc = reparse('([a-z]+) ([a-z]+) ([a-z]+) ([a-z]+) ([a-z]+)', 'I go to the store', 'xs', 'n', 'a', 'p', 'd', 'x')
-
-test = 'parse with s flag'
-if \rcc then fail(test)
-if n \= 'I' then fail(test', first variable' n)
-if a \= 'go' then fail(test', second variable' a)
-if p \= 'to' then fail(test', third variable' p)
-if d \= 'the' then fail(test', fourth variable' d)
-if x \= 'store' then fail(test', last variable' x)
-say 'pass' test
-
-rcc = reparse('([a-z]+) ([a-z]+) ([a-z]+) ([a-z]+) ([a-z]+)', 'I go to the store', 'xst', 'bo')
-
-test = 'parse with s and t flags'
-if \rcc then fail(test)
-if bo.0 \= 5 then fail(test', bo.0' bo.0)
-if bo.1 \= 'I' then fail(test', first variable' bo.1)
-if bo.2 \= 'go' then fail(test', second variable' bo.2)
-if bo.3 \= 'to' then fail(test', third variable' bo.3)
-if bo.4 \= 'the' then fail(test', fourth variable' bo.4)
-if bo.5 \= 'store' then fail(test', last variable' bo.5)
-say 'pass' test
-
-rcc = reparse('([a-z]+) ([a-z]+) ([a-z]+) ([a-z]+) ([a-z]+)', 'I go to the store', 'xsc', 'n', 'a', 'p', 'd', 'x')
-
-test = 'parse with s and c flags'
-if rcc then fail(test)
-if n \= '' then fail(test', first variable' n)
-if a \= '' then fail(test', second variable' a)
-if p \= '' then fail(test', third variable' p)
-if d \= '' then fail(test', fourth variable' d)
-if x \= '' then fail(test', last variable' x)
-say 'pass' test
-
-rcc = reparse(' *[0-9]+ *', '17 Captions 18 Frogs 23 Legs 17 Subtitles 28 French 30 German', 'x', 'n', 'a', 'p', 'd', 'x', '.')
-
-test = 'parse with no flags, trailing dot'
-if \rcc then fail(test)
-if n \= '' then fail(test', first variable' n)
-if a \= 'Captions' then fail(test', second variable' a)
-if p \= 'Frogs' then fail(test', third variable' p)
-if d \= 'Legs' then fail(test', fourth variable' d)
-if x \= 'Subtitles' then fail(test', last variable' x)
-say 'pass' test
-
-rcc = reparse(' *[0-9]+ *', '17 Captions 18 Frogs 23 Legs 17 Subtitles 28 French 30 German', 'x', 'n', 'a', 'p', 'd', 'x')
-
-test = 'parse with no flags'
-if \rcc then fail(test)
-if n \= '' then fail(test', first variable' n)
-if a \= 'Captions' then fail(test', second variable' a)
-if p \= 'Frogs' then fail(test', third variable' p)
-if d \= 'Legs' then fail(test', fourth variable' d)
-if x \= 'Subtitles 28 French 30 German' then fail(test', last variable' x)
-say 'pass' test
-
-rcc = reparse(' *[0-9]+ *', '17 Captions 18 Frogs 23 Legs 17 Subtitles 28 French 30 German', 'xt', 'bo')
-
-test = 'parse with t flag'
-if \rcc then fail(test)
-if bo.0 \= 7 then fail(test', wrong count' bo.0)
-if bo.1 \= '' then fail(test', first variable' bo.1)
-if bo.2 \= 'Captions' then fail(test', second variable' bo.2)
-if bo.3 \= 'Frogs' then fail(test', third variable' bo.3)
-if bo.4 \= 'Legs' then fail(test', fourth variable' bo.4)
-if bo.5 \= 'Subtitles' then fail(test', fifth variable' bo.5)
-if bo.6 \= 'French' then fail(test', sixth variable' bo.6)
-if bo.7 \= 'German' then fail(test', seventh variable' bo.7)
-say 'pass' test
-
-rcc = reparse('[a-z]+', '17 Captions 18 Frogs 23 Legs 17 Subtitles 28 French 30 German', 'xv', 'n', 'a', 'p', 'd', 'x')
-
-test = 'parse with v flag'
-if \rcc then fail(test)
-if n \= 'Captions' then fail(test', second variable' n)
-if a \= 'Frogs' then fail(test', third variable' a)
-if p \= 'Legs' then fail(test', fourth variable' p)
-if d \= 'Subtitles' then fail(test', last variable' d)
-if x \= ' 28 French 30 German' then fail(test', last variable' x)
-say 'pass' test
-
-rcc = reparse('[a-z]+', '17 Captions 18 Frogs 23 Legs 17 Subtitles 28 French 30 German', 'xvt', 'bo')
-
-test = 'parse with t and v flags'
-if \rcc then fail(test)
-if bo.0 \= 6 then fail(test', wrong count' bo.0)
-if bo.1 \= 'Captions' then fail(test', first variable' bo.1)
-if bo.2 \= 'Frogs' then fail(test', second variable' bo.2)
-if bo.3 \= 'Legs' then fail(test', third variable' bo.3)
-if bo.4 \= 'Subtitles' then fail(test', fourth variable' bo.4)
-if bo.5 \= 'French' then fail(test', fifth variable' bo.5)
-if bo.6 \= 'German' then fail(test', sixth variable' bo.6)
-say 'pass' test
-
-say '****' 'compiled parse tests'
-
-cre = ReComp('[a-z][a-z]*')
-test = 'compile basic'
-if left(cre,1) then fail(test)
-say 'pass' test
-
-rcc = reparse(cre, 'noodles are poodles', 'v', 'n', 'a', 'p', 'd', 'x')
-
-test = 'parse with v flag'
-if \rcc then fail(test)
-if n \= 'noodles' then fail(test', first variable' n)
-if a \= 'are' then fail(test', second variable' a)
-if p \= 'poodles' then fail(test', third variable' p)
-if d \= '' then fail(test', extra variable' d)
-if x \= '' then fail(test', last variable' x)
-say 'pass' test
-
-call ReFree cre
-
-cre = ReComp('([a-z]+) ([a-z]+) ([a-z]+) ([a-z]+) ([a-z]+)', 'x')
-test = 'compile extended with subexpressions'
-if left(cre,1) then fail(test)
-say 'pass' test
-
-rcc = reparse(cre, 'I go to the store', 'xs', 'n', 'a', 'p', 'd', 'x')
-
-test = 'parse with s flag'
-if \rcc then fail(test)
-if n \= 'I' then fail(test', first variable' n)
-if a \= 'go' then fail(test', second variable' a)
-if p \= 'to' then fail(test', third variable' p)
-if d \= 'the' then fail(test', fourth variable' d)
-if x \= 'store' then fail(test', last variable' x)
-say 'pass' test
-
-rcc = reparse(cre, 'I go to the store', 'xst', 'bo')
-
-test = 'parse with s and t flags'
-if \rcc then fail(test)
-if bo.0 \= 5 then fail(test', bo.0' bo.0)
-if bo.1 \= 'I' then fail(test', first variable' bo.1)
-if bo.2 \= 'go' then fail(test', second variable' bo.2)
-if bo.3 \= 'to' then fail(test', third variable' bo.3)
-if bo.4 \= 'the' then fail(test', fourth variable' bo.4)
-if bo.5 \= 'store' then fail(test', last variable' bo.5)
-say 'pass' test
-
-call ReFree cre
-
-cre = ReComp('([a-z]+) ([a-z]+) ([a-z]+) ([a-z]+) ([a-z]+)', 'xc')
-test = 'compile extended with subexpressions, case-sensitive'
-if left(cre,1) then fail(test)
-say 'pass' test
-
-rcc = reparse(cre, 'I go to the store', 'xsc', 'n', 'a', 'p', 'd', 'x')
-
-test = 'parse with s and c flags'
-if rcc then fail(test)
-if n \= '' then fail(test', first variable' n)
-if a \= '' then fail(test', second variable' a)
-if p \= '' then fail(test', third variable' p)
-if d \= '' then fail(test', fourth variable' d)
-if x \= '' then fail(test', last variable' x)
-say 'pass' test
-
-call ReFree cre
-
-cre = ReComp(' *[0-9]+ *', 'x')
-test = 'compile extended delimiter'
-if left(cre,1) then fail(test)
-say 'pass' test
-
-rcc = reparse(cre, '17 Captions 18 Frogs 23 Legs 17 Subtitles 28 French 30 German', 'x', 'n', 'a', 'p', 'd', 'x', '.')
-
-test = 'parse with no flags, trailing dot'
-if \rcc then fail(test)
-if n \= '' then fail(test', first variable' n)
-if a \= 'Captions' then fail(test', second variable' a)
-if p \= 'Frogs' then fail(test', third variable' p)
-if d \= 'Legs' then fail(test', fourth variable' d)
-if x \= 'Subtitles' then fail(test', last variable' x)
-say 'pass' test
-
-rcc = reparse(cre, '17 Captions 18 Frogs 23 Legs 17 Subtitles 28 French 30 German', 'x', 'n', 'a', 'p', 'd', 'x')
-
-test = 'parse with no flags'
-if \rcc then fail(test)
-if n \= '' then fail(test', first variable' n)
-if a \= 'Captions' then fail(test', second variable' a)
-if p \= 'Frogs' then fail(test', third variable' p)
-if d \= 'Legs' then fail(test', fourth variable' d)
-if x \= 'Subtitles 28 French 30 German' then fail(test', last variable' x)
-say 'pass' test
-
-rcc = reparse(cre, '17 Captions 18 Frogs 23 Legs 17 Subtitles 28 French 30 German', 'xt', 'bo')
-
-test = 'parse with t flag'
-if \rcc then fail(test)
-if bo.0 \= 7 then fail(test', wrong count' bo.0)
-if bo.1 \= '' then fail(test', first variable' bo.1)
-if bo.2 \= 'Captions' then fail(test', second variable' bo.2)
-if bo.3 \= 'Frogs' then fail(test', third variable' bo.3)
-if bo.4 \= 'Legs' then fail(test', fourth variable' bo.4)
-if bo.5 \= 'Subtitles' then fail(test', fifth variable' bo.5)
-if bo.6 \= 'French' then fail(test', sixth variable' bo.6)
-if bo.7 \= 'German' then fail(test', seventh variable' bo.7)
-say 'pass' test
-
-call ReFree cre
-
-cre = ReComp('[a-z]+', 'x')
-test = 'compile extended'
-if left(cre,1) then fail(test)
-say 'pass' test
-
-rcc = reparse(cre, '17 Captions 18 Frogs 23 Legs 17 Subtitles 28 French 30 German', 'xv', 'n', 'a', 'p', 'd', 'x')
-
-test = 'parse with v flag'
-if \rcc then fail(test)
-if n \= 'Captions' then fail(test', second variable' n)
-if a \= 'Frogs' then fail(test', third variable' a)
-if p \= 'Legs' then fail(test', fourth variable' p)
-if d \= 'Subtitles' then fail(test', last variable' d)
-if x \= ' 28 French 30 German' then fail(test', last variable' x)
-say 'pass' test
-
-rcc = reparse(cre, '17 Captions 18 Frogs 23 Legs 17 Subtitles 28 French 30 German', 'xvt', 'bo')
-
-test = 'parse with t and v flags'
-if \rcc then fail(test)
-if bo.0 \= 6 then fail(test', wrong count' bo.0)
-if bo.1 \= 'Captions' then fail(test', first variable' bo.1)
-if bo.2 \= 'Frogs' then fail(test', second variable' bo.2)
-if bo.3 \= 'Legs' then fail(test', third variable' bo.3)
-if bo.4 \= 'Subtitles' then fail(test', fourth variable' bo.4)
-if bo.5 \= 'French' then fail(test', fifth variable' bo.5)
-if bo.6 \= 'German' then fail(test', sixth variable' bo.6)
-say 'pass' test
-
-call ReFree cre
-
-rec = recomp('C[auo]t[a-z]*', 'c')
-
-test = 'compile case sensitive'
-if left(rec, 1) then fail(test ReError(rec))
-say 'pass' test
-
-rei = recomp('C[auo]t[a-z]*')
-
-test = 'compile case insensitive'
-if left(rei, 1) then fail(test ReError(rei))
-say 'pass' test
-
-target = 'On the cot, a catatonic cat named Catherine cut things.'
-test = 'parse repeatedly with v flag, case sensitive, pass 1'
-rcc = ReParse(rec, target, 'v', 'match', 'target')
-if \rcc then fail(test)
-if match \= 'Catherine' then fail(test', matched' match)
-if target \= ' cut things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with v flag, case sensitive, pass 2'
-rcc = ReParse(rec, target, 'v', 'match', 'target')
-if rcc then fail(test)
-if match \= '' then fail(test', matched' match)
-if target \= ' cut things.' then fail(test', remainder' target)
-say 'pass' test
-
-target = 'On the cot, a catatonic cat named Catherine cut things.'
-test = 'parse repeatedly with v flag, case insensitive, pass 1'
-rcc = ReParse(rei, target, 'v', 'match', 'target')
-if \rcc then fail(test)
-if match \= 'cot' then fail(test', matched' match)
-if target \= ', a catatonic cat named Catherine cut things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with v flag, case insensitive, pass 2'
-rcc = ReParse(rei, target, 'v', 'match', 'target')
-if \rcc then fail(test)
-if match \= 'catatonic' then fail(test', matched' match)
-if target \= ' cat named Catherine cut things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with v flag, case insensitive, pass 3'
-rcc = ReParse(rei, target, 'v', 'match', 'target')
-if \rcc then fail(test)
-if match \= 'cat' then fail(test', matched' match)
-if target \= ' named Catherine cut things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with v flag, case insensitive, pass 4'
-rcc = ReParse(rei, target, 'v', 'match', 'target')
-if \rcc then fail(test)
-if match \= 'Catherine' then fail(test', matched' match)
-if target \= ' cut things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with v flag, case insensitive, pass 5'
-rcc = ReParse(rei, target, 'v', 'match', 'target')
-if \rcc then fail(test)
-if match \= 'cut' then fail(test', matched' match)
-if target \= ' things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with v flag, case insensitive, pass 6'
-rcc = ReParse(rei, target, 'v', 'match', 'target')
-if rcc then fail(test)
-if match \= '' then fail(test', matched' match)
-if target \= ' things.' then fail(test', remainder' target)
-say 'pass' test
-
-call ReFree rec, rei
-
-cre = ReComp('[[:blank:]][[:blank:]]*')
-test = 'compile basic with character class'
-if left(cre,1) then fail(test)
-say 'pass' test
-
-target = 'On the cot, a catatonic cat named Catherine cut things.'
-test = 'parse repeatedly with no flags, pass 1'
-rcc = ReParse(cre, target, , 'match', 'target')
-if \rcc then fail(test)
-if match \= 'On' then fail(test', matched' match)
-if target \= 'the cot, a catatonic cat named Catherine cut things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with no flags, pass 2'
-rcc = ReParse(cre, target, , 'match', 'target')
-if \rcc then fail(test)
-if match \= 'the' then fail(test', matched' match)
-if target \= 'cot, a catatonic cat named Catherine cut things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with no flags, pass 3'
-rcc = ReParse(cre, target, , 'match', 'target')
-if \rcc then fail(test)
-if match \= 'cot,' then fail(test', matched' match)
-if target \= 'a catatonic cat named Catherine cut things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with no flags, pass 4'
-rcc = ReParse(cre, target, , 'match', 'target')
-if \rcc then fail(test)
-if match \= 'a' then fail(test', matched' match)
-if target \= 'catatonic cat named Catherine cut things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with no flags, pass 5'
-rcc = ReParse(cre, target, , 'match', 'target')
-if \rcc then fail(test)
-if match \= 'catatonic' then fail(test', matched' match)
-if target \= 'cat named Catherine cut things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with no flags, pass 6'
-rcc = ReParse(cre, target, , 'match', 'target')
-if \rcc then fail(test)
-if match \= 'cat' then fail(test', matched' match)
-if target \= 'named Catherine cut things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with no flags, pass 7'
-rcc = ReParse(cre, target, , 'match', 'target')
-if \rcc then fail(test)
-if match \= 'named' then fail(test', matched' match)
-if target \= 'Catherine cut things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with no flags, pass 8'
-rcc = ReParse(cre, target, , 'match', 'target')
-if \rcc then fail(test)
-if match \= 'Catherine' then fail(test', matched' match)
-if target \= 'cut things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with no flags, pass 9'
-rcc = ReParse(cre, target, , 'match', 'target')
-if \rcc then fail(test)
-if match \= 'cut' then fail(test', matched' match)
-if target \= 'things.' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with no flags, pass 10'
-rcc = ReParse(cre, target, , 'match', 'target')
-if \rcc then fail(test)
-if match \= 'things.' then fail(test', matched' match)
-if target \= '' then fail(test', remainder' target)
-say 'pass' test
-
-test = 'parse repeatedly with no flags, pass 11'
-rcc = ReParse(cre, target, , 'match', 'target')
-if \rcc then fail(test)
-if match \= '' then fail(test', matched' match)
-if target \= '' then fail(test', remainder' target)
-say 'pass' test
-
-call ReFree cre
-
-say '****' 'exec tests'
-
-re = recomp('([[:digit:]]+) +([[:digit:]]+)', 'x')
-
-test = 'compile with character class'
-if left(re, 1) then fail(test ReError(re))
-say 'pass' test
-
-rcc = reexec(re, '234 159', 'bo')
-
-test = 'exec no flags'
-if \rcc then fail(test)
-if bo.0 \= 2 then fail(test', count' bo.0)
-if bo.1 \= 234 then fail(test', first match' bo.1)
-if bo.2 \= 159 then fail(test', second match' bo.2)
-if bo.!match \= '234 159' then fail(test', full match' bo.!match)
-say 'pass' test
-
-rcc = reexec(re, '234 159', 'bo', 'p')
-
-test = 'exec p flag'
-if \rcc then fail(test)
-if bo.0 \= 2 then fail(test', count' bo.0)
-if bo.1 \= '1 3' then fail(test', first match' bo.1)
-if bo.2 \= '5 3' then fail(test', second match' bo.2)
-if bo.!match \= '1 7' then fail(test', full match' bo.!match)
-say 'pass' test
-
-call ReFree re
-
-rec = recomp('C[auo]t', 'c')
-
-test = 'compile case sensitive'
-if left(rec, 1) then fail(test ReError(rec))
-say 'pass' test
-
-rei = recomp('C[auo]t')
-
-test = 'compile case insensitive'
-if left(rei, 1) then fail(test ReError(rei))
-say 'pass' test
-
-target = 'On the cot, a catatonic cat named Catherine cut things.'
-
-test = 'exec case sensitive'
-if \ReExec(rec, target, 'bo') then fail(test)
-if bo.!match \= 'Cat' then fail(test', matched' bo.!match)
-say 'pass' test
-
-test = 'exec case insensitive'
-if \ReExec(rei, target, 'bo') then fail(test)
-if bo.!match \= 'cot' then fail(test', matched' bo.!match)
-say 'pass' test
-
-test = 'exec positions case sensitive'
-if \ReExec(rec, target, 'bo', 'p') then fail(test)
-if bo.!match \= '35 3' then fail(test', matched' bo.!match)
-say 'pass' test
-
-test = 'exec positions case insensitive'
-if \ReExec(rei, target, 'bo', 'p') then fail(test)
-if bo.!match \= '8 3' then fail(test', matched' bo.!match)
-say 'pass' test
-
-call ReFree rec, rei
-
-say '**** All tests passed'
-
-exit 0
-
-fail:
-	parse arg reason
-	say 'fail' reason 'at line' sigl
-	exit 1
diff -ruN rexxre/rexxre.c rexxre-patch/rexxre.c
--- rexxre/rexxre.c	2003-05-26 14:42:46.000000000 +1200
+++ rexxre-patch/rexxre.c	1970-01-01 13:00:00.000000000 +1300
@@ -1,581 +0,0 @@
-/* regular expression routines for rexx
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS"
- * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
- * License for the specific language governing rights and limitations
- * under the License.
- *
- * The Original Code is regutil.
- *
- * The Initial Developer of the Original Code is Patrick TJ McPhee.
- * Portions created by Patrick McPhee are Copyright © 2003
- * Patrick TJ McPhee. All Rights Reserved.
- *
- * Contributors:
- *
- * $Header: C:/ptjm/rexx/rexxre/RCS/rexxre.c 1.8 2003/05/26 19:42:46 ptjm Rel $
- */
-
-/* these routines are based on POSIX regular expressions. IBM's Object Rexx
- * includes a regular expression object which is NOT based on POSIX regular
- * expressions, but is confusingly similar. I'm not currently supporting
- * that because I don't know what's in it ... */
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <sys/types.h>
-#include <regex.h>
-#include "rxproto.h"
-
-/* routines: recomp -- compiles a regular expression
- *           reexec -- applies a regular expression to a string
- *           refree -- releases the compiled regular expression
- *           reerror -- explains error codes
- *           reparse -- parses a value according to a regular expression
- *           reversion -- returns the library version number
- *           reloadfuncs -- loads all the other functions
- *           redropfuncs -- unloads all the functions
- */
-
-typedef struct {
-   char failureflag[2];
-   int  rc;
-   regex_t re;
-} cre_t;
-
-#define REMAGIC 29
-
-
-/* compile regular expression -- arguments are the RE and flags.
- * return code is the compiled regular expression.
- * flags are `x' to get extended regular expressions
- *           `c' to get case-sensitive comparisons
- *           `s' to get status-only (no position)
- *           `n' to have newlines take on a special meaning */
-rxfunc(recomp)
-{
-   cre_t reg;
-   int flags = REG_BASIC|REG_ICASE;
-   char * re;
-   register int i, rc;
-   
-   checkparam(1, 2);
-
-   rxstrdup(re, argv[0]);
-   if (argc > 1) {
-      for (i = 0; i < argv[1].strlength; i++) {
-         switch (argv[1].strptr[i]) {
-            case 'X':
-            case 'x': flags |= REG_EXTENDED; break;
-            case 'C':
-            case 'c': flags &= ~REG_ICASE; break;
-            case 'S':
-            case 's': flags |= REG_NOSUB; break;
-            case 'N':
-            case 'n': flags |= REG_NEWLINE; break;
-            default: return BADARGS; break;
-         }
-      }
-   }
-
-   reg.rc = regcomp(&reg.re, re, flags);
-
-   if (!reg.rc) {
-      reg.failureflag[0] = '0';
-   }
-   else {
-      reg.failureflag[0] = '1';
-   }
-
-   reg.failureflag[1] = REMAGIC;
-
-   memcpy(result->strptr, &reg, sizeof(reg));
-   result->strlength = sizeof(reg);
-
-   return 0;
-}
-
-/* reexec(re, string[, matches[, flags]])
- *  flags are `b' -- the string does not start at the beginning of a line
- *            `e' -- the string does not start at the end of a line
- *            `p' -- return the positions of matched strings, rather than the strings
- *                   themselves */
-rxfunc(reexec)
-{
-   cre_t * reg, dreg;
-   int flags = 0, cflags = REG_BASIC|REG_ICASE;
-   int retstr = 1;
-   int rc;
-   register int i;
-   char * str;
-   RXSTRING fullmatch;
-   static const char fullmatchcomposite[] = "!MATCH";
-   regmatch_t * rmt = NULL;;
-   
-   checkparam(2, 4);
-
-   if (argv[0].strlength == 0) {
-      return BADARGS;
-   }
-
-   if (argc == 4) {
-      for (i = 0; i < argv[3].strlength; i++) {
-         switch (argv[3].strptr[i]) {
-            case 'X':
-            case 'x': cflags |= REG_EXTENDED; break;
-            case 'C':
-            case 'c': cflags &= ~REG_ICASE; break;
-            case 'S':
-            case 's': cflags |= REG_NOSUB; break;
-            case 'N':
-            case 'n': cflags |= REG_NEWLINE; break;
-
-            case 'B':
-            case 'b': flags |= REG_NOTBOL; break;
-            case 'E':
-            case 'e': flags |= REG_NOTEOL; break;
-            case 'P':
-            case 'p': retstr = 0; break;
-            default: return BADARGS;
-         }
-      }
-   }
-
-
-   /* guess whether this is a compiled RE -- anything which isn't the
-    * right size size definitely isn't, and anything which is the right
-    * size bug doesn't have the right magic numbers in the first few
-    * characters probably aren't
-    */
-   if (argv[0].strlength != sizeof(*reg) || argv[0].strptr[1] != REMAGIC ||
-       (argv[0].strptr[0] != '0' && argv[0].strptr[0] != '1')) {
-      rxstrdup(str, argv[0]);
-      reg = &dreg;
-      reg->rc = regcomp(&reg->re, str, cflags);
-
-      /* too bad -- there's no way to know why it failed */
-      if (reg->rc) {
-         regfree(&reg->re);
-         result_zero();
-         return 0;
-      }
-   }
-
-   else {
-      reg = (cre_t *)argv[0].strptr;
-   }
-
-   rmt = calloc(sizeof(*rmt), reg->re.re_nsub+1);
-   if (!rmt) {
-      if (reg == &dreg)
-         regfree(&reg->re);
-      return NOMEMORY;
-   }
-
-   str = malloc(argv[1].strlength + 1);
-   if (!str) {
-      free(rmt);
-      if (reg == &dreg)
-         regfree(&reg->re);
-      return NOMEMORY;
-   }
-
-   memcpy(str, argv[1].strptr, argv[1].strlength);
-   str[argv[1].strlength] = 0;
-   
-   rc = regexec(&reg->re, str, reg->re.re_nsub+1, rmt, flags);
-
-   if (rc == 0) {
-      result_one();
-   }
-   else {
-      result_zero();
-   }
-   
-   if (argc > 2 && argv[2].strptr) {
-      chararray * ca = new_chararray();
-
-      if (retstr) {
-         for (i = 1; i < reg->re.re_nsub+1; i++) {
-            cha_adddummy(ca, str+rmt[i].rm_so, rmt[i].rm_eo-rmt[i].rm_so);
-         }
-      }
-      else {
-         char buf[40];
-         int bufl;
-
-         for (i = 1; i < reg->re.re_nsub+1; i++) {
-            bufl = sprintf(buf, "%d %d", (int)rmt[i].rm_so+1, (int)rmt[i].rm_eo - rmt[i].rm_so);
-            cha_addstr(ca, buf, bufl);
-         }
-      }
-
-      setastem(argv+2, ca);
-      delete_chararray(ca);
-
-      fullmatch.strptr = alloca(argv[2].strlength+sizeof(fullmatchcomposite)+1);
-      memcpy(fullmatch.strptr, argv[2].strptr, argv[2].strlength);
-      if (fullmatch.strptr[argv[2].strlength-1] == '.') {
-         fullmatch.strlength = argv[2].strlength;
-      }
-      else {
-         fullmatch.strptr[argv[2].strlength] = '.';
-         fullmatch.strlength = argv[2].strlength + 1;
-      }
-
-      memcpy(fullmatch.strptr+fullmatch.strlength, fullmatchcomposite,
-             sizeof(fullmatchcomposite)-1);
-      fullmatch.strlength += sizeof(fullmatchcomposite)-1;
-
-      if (retstr) {
-         setavar(&fullmatch, str+rmt[0].rm_so, rmt[0].rm_eo-rmt[0].rm_so);
-      }
-      else {
-         char buf[40];
-         int bufl;
-         bufl = sprintf(buf, "%d %d", (int)rmt[0].rm_so+1, (int)rmt[0].rm_eo - rmt[0].rm_so);
-         setavar(&fullmatch, buf, bufl);
-      }
-   }
-
-   if (rmt) {
-      free(rmt);
-   }
-
-   if (reg == &dreg)
-      regfree(&reg->re);
-
-   free(str);
-
-   return 0;
-}
-
-/* refree(re) */
-rxfunc(refree)
-{
-   cre_t * reg;
-   register int i;
-
-   checkparam(1, 1000);
-
-   for (i = 0; i < argc; i++) {
-      if (argv[i].strlength != sizeof(*reg)) {
-         return BADARGS;
-      }
-
-      reg = (cre_t *)argv[i].strptr;
-
-      regfree(&reg->re);
-   }
-
-   result_zero();
-   return 0;
-}
-
-/* reerror(re) */
-rxfunc(reerror)
-{
-   cre_t * reg;
-
-   checkparam(1, 1);
-
-   if (argv[0].strlength != sizeof(*reg)) {
-      return BADARGS;
-   }
-
-   reg = (cre_t *)argv[0].strptr;
-
-
-   result->strlength = regerror(reg->rc, &reg->re, result->strptr, DEFAULTSTRINGSIZE);
-
-   return 0;
-}
-
-/* reparse(expression, value, flags, varname[, varname, ...])
- *   flags are:
- *       'x': use extended regular expressions;
- *       'c': respect case
- *       'n': newlines denote line-ends
- *       's': match variables to sub-expressions
- *       'd': re is the value delimiter (default)
- *       'v': re matches a var
- *       't': first var is a stem for all the fields
- */
-rxfunc(reparse)
-{
-   cre_t * reg, dreg;
-   regmatch_t * rmt;
-   register int i, j, oldi, voldi, sd;
-   int flags = REG_BASIC|REG_ICASE, rc;
-   enum { sub, var, delim } matchmode = delim;
-   char * str, *re;
-   chararray * ca = NULL;
-   
-   checkparam(4, 10000);
-
-   if (argc > 3) {
-      for (i = 0; i < argv[2].strlength; i++) {
-         switch (argv[2].strptr[i]) {
-            case 'X':
-            case 'x': flags |= REG_EXTENDED; break;
-            case 'C':
-            case 'c': flags &= ~REG_ICASE; break;
-            case 'N':
-            case 'n': flags |= REG_NEWLINE; break;
-            case 'S':
-            case 's': matchmode = sub; break;
-            case 'D':
-            case 'd': matchmode = delim; break;
-            case 'V':
-            case 'v': matchmode = var; break;
-            case 'T':
-            case 't': ca = new_chararray(); break;
-            default: return BADARGS; break;
-         }
-      }
-   }
-
-   /* guess whether this is a compiled RE -- anything which isn't the
-    * right size size definitely isn't, and anything which is the right
-    * size bug doesn't have the right magic numbers in the first few
-    * characters probably aren't
-    */
-   if (argv[0].strlength != sizeof(*reg) || argv[0].strptr[1] != REMAGIC ||
-       (argv[0].strptr[0] != '0' && argv[0].strptr[0] != '1')) {
-      rxstrdup(re, argv[0]);
-      reg = &dreg;
-      reg->rc = regcomp(&reg->re, re, flags);
-
-      /* too bad -- there's no way to know why it failed */
-      if (reg->rc) {
-         regfree(&reg->re);
-         result_zero();
-         return 0;
-      }
-   }
-
-   else {
-      reg = (cre_t *)argv[0].strptr;
-   }
-
-   str = malloc(argv[1].strlength+1);
-   if (!str) {
-      if (reg == &dreg)
-         regfree(&reg->re);
-      return NOMEMORY;
-   }
-
-   memcpy(str, argv[1].strptr, argv[1].strlength);
-   str[argv[1].strlength] = 0;
-
-   rmt = calloc(sizeof(*rmt), reg->re.re_nsub+1);
-   if (!rmt) {
-      free(str);
-      if (reg == &dreg)
-         regfree(&reg->re);
-      return NOMEMORY;
-   }
-
-   result_zero();
-   j = 0;
-   switch (matchmode) {
-      case sub: {
-         rc = regexec(&reg->re, str, reg->re.re_nsub+1, rmt, 0);
-         if (!rc) {
-            result_one();
-            if (ca) {
-               for (i = 1; i < (reg->re.re_nsub+1); i++) {
-                  cha_adddummy(ca, str+rmt[i].rm_so, rmt[i].rm_eo-rmt[i].rm_so);
-               }
-            }
-            else {
-               for (i = 1, j = 3; i < (reg->re.re_nsub+1) && j < argc; i++, j++) {
-                  setavar(argv+j, str+rmt[i].rm_so, rmt[i].rm_eo-rmt[i].rm_so);
-               }
-            }
-         }
-      }
-         break;
-      case var: {
-         for (rc = regexec(&reg->re, str, reg->re.re_nsub+1, rmt, 0), j = 3, i = voldi = sd = 0, oldi = -1;
-              !rc && (ca || j < argc);
-              i += sd + rmt[0].rm_eo, rc = regexec(&reg->re, str+i, reg->re.re_nsub+1, rmt, 0), j++) {
-            result_one();
-
-            /* If the end offset doesn't move, we need to advance over
-             * the next character to avoid a hang.
-             * If it doesn't move and we're starting from the end of the
-             * previous match, then we've just matched the same thing twice
-             * and should ignore this one.
-             */
-            if (sd = !rmt[0].rm_eo) {
-               if (i == oldi) {
-                  if (!str[i]) {
-                     break;
-                  }
-                  else {
-                     j--;
-                     continue;
-                  }
-               }
-               else if (!str[i]) {
-                  sd = 0;
-               }
-            }
-
-            if (ca)
-               cha_addstr(ca, str+i+rmt[0].rm_so, rmt[0].rm_eo-rmt[0].rm_so);
-            else
-               setavar(argv+j, str+i+rmt[0].rm_so, rmt[0].rm_eo - rmt[0].rm_so);
-
-            voldi = oldi;
-            oldi = i + (int)rmt[0].rm_eo;
-         }
-
-         /* to match the behaviour of the parse expression, we map everything
-          * that's left to the last field */
-         if (!ca) {
-            if (j == argc) {
-               setavar(argv+j-1, str+voldi, argv[1].strlength - voldi);
-            }
-            else if (rc) {
-               argc--;
-               setavar(argv+argc, str+i, argv[1].strlength - i);
-            }
-         }
-      }
-         break;
-      case delim: {
-         /* we always match by definition, since the field is whatever
-          * doesn't match the delimiter */
-         result_one();
-         for (rc = regexec(&reg->re, str, reg->re.re_nsub+1, rmt, 0), j = 3, i = 0, oldi = -1, voldi = 0;
-              !rc && (ca || j < argc);
-              i += sd + rmt[0].rm_eo, rc = regexec(&reg->re, str+i, reg->re.re_nsub+1, rmt, 0), j++) {
-
-            /* same argument about matching zero-length strings applies here,
-             * although it would be perverse to allow a zero-length
-             * delimiter */
-            if (sd = !rmt[0].rm_eo) {
-               if (i == oldi) {
-                  if (!str[i]) {
-                     break;
-                  }
-                  else {
-                     j--;
-                     continue;
-                  }
-               }
-               else if (!str[i]) {
-                  sd = 0;
-               }
-            }
-
-            if (ca)
-               cha_addstr(ca, str+i, rmt[0].rm_so);
-            else
-               setavar(argv+j, str+i, rmt[0].rm_so);
-
-            voldi = oldi;
-            oldi = i + (int)rmt[0].rm_eo;
-         }
-
-         /* to match the behaviour of the parse expression, we map everything
-          * that's left to the last field */
-         if (!ca) {
-            if (j == argc) {
-               j--;
-               i = voldi;
-            }
-
-            setavar(argv+j, str+i, argv[1].strlength - i);
-            j++;
-         }
-         else {
-            cha_addstr(ca, str+i, argv[1].strlength - i);
-         }
-      }
-         break;
-   }
-
-   if (ca) {
-      setastem(argv+3, ca);
-      delete_chararray(ca);
-   }
-   else {
-      for (; j < argc; j++) {
-         setavar(argv+j, "", 0);
-      }
-   }
-
-
-   if (reg == &dreg)
-      regfree(&reg->re);
-
-   free(rmt);
-   free(str);
-
-   return 0;
-}
-
-rxfunc(reversion)
-{
-   static const char version[] = "1.0.1";
-   memcpy(result->strptr, version, sizeof(version)-1);
-   result->strlength = sizeof(version) - 1;
-   return 0;
-}
-
-
-rxfunc(reloadfuncs);
-rxfunc(redropfuncs);
-
-struct {
-    char * name;
-    APIRET (APIENTRY*funcptr)(PUCHAR fname, ULONG argc, PRXSTRING argv, PSZ pSomething, PRXSTRING result);
-} funclist[] = {
-    {"RECOMP", recomp},
-    {"REEXEC", reexec},
-    {"REFREE", refree},
-    {"REERROR", reerror},
-    {"REPARSE", reparse},
-    {"REVERSION", reversion},
-    {"REDROPFUNCS", redropfuncs},
-    {"RELOADFUNCS", reloadfuncs}
-};
-
-/* reloadfuncs() */
-rxfunc(reloadfuncs)
-{
-    register int i;
-
-    checkparam(0,0);
-
-    for (i = 0; i < DIM(funclist); i++) {
-	RexxRegisterFunctionExe(funclist[i].name, funclist[i].funcptr);
-    }
-
-    result_zero();
-
-    return 0;
-}
-
-/* redropfuncs() */
-rxfunc(redropfuncs)
-{
-    register int i;
-    checkparam(0,0);
-
-    for (i = 0; i < DIM(funclist); i++) {
-	RexxDeregisterFunction(funclist[i].name);
-    }
-
-    result_zero();
-    return 0;
-}
diff -ruN rexxre/rexxre.def rexxre-patch/rexxre.def
--- rexxre/rexxre.def	2003-04-29 11:26:20.000000000 +1200
+++ rexxre-patch/rexxre.def	1970-01-01 13:00:00.000000000 +1300
@@ -1,9 +0,0 @@
-LIBRARY rexxre
-EXPORTS recomp
-EXPORTS reexec
-EXPORTS refree
-EXPORTS reerror
-EXPORTS reparse
-EXPORTS reversion
-EXPORTS reloadfuncs
-EXPORTS redropfuncs
Binary files rexxre/rexxre.pdf and rexxre-patch/rexxre.pdf differ
diff -ruN rexxre/rexxre.rc rexxre-patch/rexxre.rc
--- rexxre/rexxre.rc	2003-05-26 14:08:56.000000000 +1200
+++ rexxre-patch/rexxre.rc	1970-01-01 13:00:00.000000000 +1300
@@ -1,33 +0,0 @@
-#include <winuser.h>
-#include <winres.h>
-
-VS_VERSION_INFO VERSIONINFO
- FILEVERSION 1,0,1,0
- PRODUCTVERSION 1,0,1,0
- FILEFLAGSMASK 0x3fL
-#ifdef _DEBUG
- FILEFLAGS 0x1L
-#else
- FILEFLAGS 0x0L
-#endif
- FILEOS 0x40004L
- FILETYPE 0x2L
- FILESUBTYPE 0x0L
-BEGIN
-    BLOCK "StringFileInfo"
-    BEGIN
-        BLOCK "040904b0"
-        BEGIN
-            VALUE "CompanyName", "Patrick TJ McPhee\0"
-            VALUE "ProductName", "Rexx regular expression library\0"
-            VALUE "ProductVersion", "1.0.1\0"
-            VALUE "FileVersion", "1.0.1\0"
-            VALUE "FileDescription", "A POSIX regular expression library for rexx\0"
-            VALUE "LegalCopyright", "Copyright © 2003 Patrick TJ McPhee. Copyright © 1992 Henry Spencer. Copyright © 1992, 1993 The Regents of the University of California.\0"
-        END
-    END
-    BLOCK "VarFileInfo"
-    BEGIN
-        VALUE "Translation", 0x409, 1200
-    END
-END
diff -ruN rexxre/rexxre.tex rexxre-patch/rexxre.tex
--- rexxre/rexxre.tex	2003-05-26 13:47:14.000000000 +1200
+++ rexxre-patch/rexxre.tex	1970-01-01 13:00:00.000000000 +1300
@@ -1,782 +0,0 @@
-%% Documentation for RexxRe
-
-%  The contents of this file are subject to the Mozilla Public License
-%  Version 1.0 (the "License"); you may not use this file except in
-%  compliance with the License. You may obtain a copy of the License at
-%  http://www.mozilla.org/MPL/
-
-%  Software distributed under the License is distributed on an "AS IS"
-%  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
-%  License for the specific language governing rights and limitations
-%  under the License.
-
-%  The Original Code is RexxRE.
-
-%  The Initial Developer of the Original Code is Patrick TJ McPhee.
-%  Portions created by Patrick McPhee are Copyright © 2003
-%  Patrick TJ McPhee. All Rights Reserved.
-
-%  Contributors:
-
-% $Header: C:/ptjm/rexx/rexxre/RCS/rexxre.tex 1.2 2003/05/26 18:47:13 ptjm Rel $
-
-\documentclass{article}
-
-% if run through pdftex, use ps fonts and turn on hyperlinking
-\ifx\pdfoutput\undefined
- \def\rarrow{\ensuremath{\to}}
- \def\hyperlink#1#2{}
- \def\href#1#2{}
-\else
- \usepackage[pdftex,pdfborder=0 0 0]{hyperref}
- % uncomment for older hyperref (or update your hyperref!)
- % \def\pdfBorderAttrs{/Border [0 0 0]}%
- \def\_{\textunderscore\penalty\hyphenpenalty}
- \usepackage[T1]{fontenc}
- \usepackage{times}
- \usepackage{mathptm}
- \pdfinfo { /Title (Rexx Regular Expression Library)
-  /Author (Patrick TJ McPhee)
-  /Keywords (rexx,regina,regular expressions)
-  /Version (1.0.1)
-  /Copyright (Copyright 2003, Patrick TJ McPhee)
- }
-\fi
-
-\makeatletter
-\def\verbatim@font{\normalfont\ttfamily\small}
-\makeatother
-
-\begin{document}
-\let\thepage\relax
-\setcounter{page}{0}
-
-\title{Rexx Regular Expression Library}
-\author{Patrick TJ McPhee (ptjm@interlog.com)}
-\date{Version 1.0.1, 26 May 2003}
-
-\maketitle
-
-\eject
-
-\pagenumbering{roman}
-
-\tableofcontents
-
-\vfil\eject
-
-\pagenumbering{arabic}
-
-\section{Introduction}
-
-This paper describes RexxRE, a set of functions which provide regular
-expression matching as defined in the POSIX specification. Regular expressions
-are commonly used in data parsing applications, and provide a useful extension
-to the Rexx function set, although some Rexx programmers consider the
-datatype(\,) function to be an adequate replacement.
-
-A regular expression (RE) is a string which represents some set of strings.
-The
-point of the regular expression routines is to search some target string for
-strings which can be represented by a regular expression.
-The simplest RE is a literal representation of exactly one string, for
-instance the RE `and' represents the string `and'. More usefully, special
-characters can be used to broaden the set of strings represented by the RE.
-The RE `roo?t' represents the strings `root' and `rot', while `[a-f0-9]\char`\{2,10\char`\}'
-represents the set of hexadecimal numbers from 2 to 10 digits long. Section
-\ref{sec:regularexpressons} gives a complete description of the regular
-expression syntax.
-
-The POSIX regular expression interface defines four functions to
-perform regular expression matching. regcomp(\,) converts a
-string representation of the regular expression into a format
-which can be efficiently compared to input strings. regexec(\,)
-performs this comparison. regerror(\,) returns error information in
-a human-readable format. regfree(\,) releases the memory used to
-hold a compiled regular expression. Each of these functions has
-a direct analog in RexxRE.
-RexxRE includes an additional function which attempts to
-emulate the popular parse instruction using regular expressions.
-
-On Unix systems, the regular expression routines are provided by
-the system. On Win32 and OS/2 platforms, I use the well-known regular
-expression routines by Henry Spencer of the University of
-Toronto, which are expected to have been brought into POSIX
-compliance by members of the CSRG at UC Berkley and by the
-FreeBSD project.
-
-\subsection{Installation}
-
-There is no installation program.
-
-On Win32 platforms, copy win32/rexxre.dll to a directory on your
-path, or the directory containing regina.exe or your rexx-enabled
-application. If you use a Rexx interpreter other than Regina,
-you either need to recompile the library using your interpreter's
-development kit or download the rexx/trans version of RexxRE.
-
-On OS/2, copy os2/rexxre.dll to a directory in your LIBPATH.
-
-On Unix, you need to compile the library. 
-The distribution does not include a configuration script, but it includes
-make files which have been known to work using the stock vendor compiler
-on several Unix systems. If you have one of those systems, link the
-appropriate make file to the name `Makefile' and build the `dist'
-target. For instance, on Solaris:
-\begin{verbatim}
-ln Makefile.sun Makefile
-make dist
-\end{verbatim}
-
-On most platforms, this builds a shared library called librexxre.so.
-On HP-UX, the file is called librexxre.sl, and on AIX, it's called
-librexxre.a. The path to this library can be set in three ways:
-
-Most Unix systems allow a shared library search path to be embedded
-into program files. If you build regina (or your rexx-enabled
-application) such that this path is set to include a directory
-such as /opt/regina/lib or /usr/local/lib, you can install
-RexxRE by copying the shared library to this directory. Otherwise,
-you need to either set an environment variable or change the way
-the system searches for shared libraries.
-
-Unix systems typically use a different path for shared libraries than
-they do for program files. The name of the environment variable used
-for the shared library path is not standardised, however most systems
-use LD\_LIBRARY\_PATH. Notable exceptions are AIX (LIBPATH) and
-HP-UX (SHLIB\_PATH for 32-bit executables, LD\_LIBRARY\_PATH for
-64-bit executables). To install RexxRE, add an appropriate directory
-to the shared library path for your machine and copy the shared
-library to that directory.
-
-Finally, some systems provide a utility (often called ldconfig) which
-can be used either to set the standard search path for shared libraries,
-or to provide a database of shared libraries. On such a system, RexxRE
-can be installed by copying the shared library to an appropriate
-directory and using this utility to add it to the search database.
-You'll need to consult your system documentation for more information.
-
-\subsection{Reporting Bugs}
-
-I don't anticipate making a lot of changes to this library in the
-future, but I would like it to be bug-free.
-
-If you find a bug, an error in the documentation, or you simply have
-a suggestion for improving the distribution, please send me details 
-at ptjm@interlog.com. It's useful to know the operating system you're
-using, the version of Regina (or Rexx/IMC), and the version of rexxre,
-and to have a set of steps for reproducing the bug.
-
-\subsection{Using RxFuncAdd}
-
-All the routines in rexxre can be loaded either directly using
-RxFuncAdd\index{RxFuncAdd}, or indirectly using ReLoadFuncs\index{ReLoadFuncs}.
-RxFuncAdd takes three arguments~-- the name of the function as it will
-be used in the rexx program, the name of the library from which to load
-the function, and the name of the function as it appears in the library.
-
-RxFuncAdd returns 0 on success, or 1 on failure. Regina has a function
-called RxFuncErrMsg which can give useful information about the reason
-for a load failure. A few common reasons for failure are:
-
-Path issues: the library is called rexxre.dll on Win32 and OS/2 platforms,
-librexxre.a on AIX, librexxre.sl on HP-UX, and librexxre.so on
-other Unix platforms. On Win32, this file needs to be in the path, or
-in the directory containing regina.exe. On OS/2, it needs to be
-in a directory specified in LIBPATH. On Unix systems, it needs
-to be in a directory listed in LIBPATH on AIX, SHLIB\_PATH on HP-UX
-32-bit, or LD\_LIBRARY\_PATH on most other Unix systems. Some systems
-have an ldconfig utility which allows you to forego setting this environment
-variable.
-
-Windows 95: early releases of windows 95 did not include msvcrt.dll, the
-C run-time library used by RexxRE. This library is sometimes installed
-with applications software. It can also be obtained through service packs,
-or from the Microsoft web site.
-
-Rexx.exe: Regina includes two executables, one called `rexx', and
-the other called `regina'. The difference is that `rexx' includes the Rexx
-interpreter as part of the executable, while `regina' loads the interpreter
-from a shared library. RxFuncAdd works only with the `regina' version of
-the interpreter (the `rexx' version is slightly faster, though).
-
-\subsection{Licencing}
-
-RexxRE is distributed free of charge in the hopes that it will be
-useful, but without any warranty. It is distributed under the terms of
-the Mozilla Public License. The precise details of the licence are found
-in the file MPL-1.1.txt in the distribution. Henry Spencer's regular
-expression routines are taken from the FreeBSD distribution and are
-distributed under the BSD licence.
-
-\goodbreak
-
-\section{Regular Expressions}
-
-\label{sec:regularexpressons} This section describes the regular expression
-(RE) format defined by the POSIX standard. Because the regular expression
-processing is actually handled by operating-system-specific functions, this
-syntax might not exactly match the syntax available on your system, and
-there's little I can do about it. Most current systems should work as
-described here. For others, you might try compiling with the Spencer routines
-found in the regex sub-directory.
-
-For historical reasons, there are two regular expression syntaxes defined by
-POSIX, which are usually called `basic' and `extended'. We are encouraged to
-use `extended' REs, however most Unix utilities actually use `basic' REs, and
-the default format for the regular expression routines is `basic'. To make
-things more confusing, many Unix utilities extend either type of RE in one way
-or another, many editors provide their own unique regular expression syntax,
-the regular expression library included with Object Rexx is similar to, but
-different from, `extended' regular expressions, and some people are familiar
-with the regular expressions provided by perl, which are syntactically
-completely different from anything else anywhere. I have elected to stick with
-the POSIX definitions since they are the only reasonable standard.
-
-\subsection{Common Syntax}
-
-Both `basic' and `extended' regular expressions consist of strings of
-characters, some of which have special meanings. The regular expression is expressed in terms of `ordinary'
-characters, which correspond to themselves, and `meta' characters,
-which generally change the way the regular expression matching is performed.
-
-The set of ordinary and meta characters differs between `basic' and
-`extended' regular expressions, however there is some common ground.
-In general, non-punctuation characters are always ordinary. `cat'
-matches only the string `cat', and `12' matches only `12'.
-
-The characters below are meta characters in both types of RE.
-Later sections list the meta characters which are specific to each type
-of RE.
-
-\begin{enumerate}
-\item[.]Matches any character. `c.t' matches `cat', `cot', `cut', `ctt',
-{\it etc}.;
-\item[[]Introduces an alternation set. `c[auo]t' matches `cat', `cut',
-or `cot', but not `ctt' or any of the other things matched by `c.t'.
-`\char`\^', `-', and `]' can have special meanings in alternation
-sets. Alternation is discussed more fully in section \ref{sec:alternation};
-\item[*]Kleene closure: matches 0 or more of whatever the preceding character
-or group of characters matches. `.*' matches any string. `a*' matches
-`', `a', `aa', {\it etc}.. The regular expression engine will take
-the first, longest match for Kleene closure. `a*' will match the
-first three characters of `aaabcaa';
-\item[\textbackslash]Escapes itself and the other meta characters.
-\textbackslash. matches `.' only. In `basic' regular expressions,
-\textbackslash{} also causes some ordinary characters to act like
-meta characters;
-\item[\char`\^]When placed at the beginning of a regular expression,
-anchors the regular expression to the start of the string being
-searched. The regular expression `at' matches the last two characters of
-`cat', but `\char`\^at' does not. Elsewhere in the regular expression,
-\char`\^\ has no special meaning;
-\item[\$]When placed at the end of a regular expression, anchors the
-regular expression to the end of the string being searched. The regular
-expression `ca' matches the first two characters of `cat', but `ca\$'
-does not.
-\end{enumerate}
-
-\subsection{Basic Regular Expressions}
-
-`Basic' regular expressions use \textbackslash{} to turn some ordinary
-characters into meta characters.
-
-\begin{enumerate}
-\item[\textbackslash(]Begins a group. The regular expression which
-appears between \textbackslash( and \textbackslash) is treated
-as a unit with respect to Kleene closure and interval operations.
-`\textbackslash(abc\textbackslash)*' matches `', `abc', `abcabc',
-{\it etc}.;
-Group contents can also be returned to the caller by the regular
-expression matching functions, and can be used in back-references;
-\item[\textbackslash)]Ends a group;
-\item[\textbackslash{\it d}]Back-reference: matches the contents
-of the {\it d}th group, where {\it d} is an integer from 1 to 9.
-`\textbackslash([cd]\textbackslash)at\textbackslash1' matches
-`catcat' and `datdat', but not `datcat';
-\item[\textbackslash\char`\{]Interval: \textbackslash\char`\{ must
-be followed by one of a whole number $w_1$, a whole number $w_2$ and a comma,
-or two whole numbers $w_3$ and $w_4$, $w_3 <w_4$ separated by a comma.
-The interval constrains the preceding character
-or group to match exactly $w_1$ instances, $w_2$ or more
-instances, or between $w_3$ and $w_4$ instances, inclusive, depending on
-the syntax used. `a\textbackslash\char`\{3\textbackslash\char`\}' matches
-the first three characters of `aaaaaa'.
-`a\textbackslash\char`\{3,\textbackslash\char`\}' matches
-all the characters of `aaaaaa' but does not match `aa'.
-`a\textbackslash\char`\{3,4\textbackslash\char`\}' matches
-the first four characters of `aaaaaa' but does not match `aa'.
-\item[\textbackslash\char`\}]Closes an interval.
-\end{enumerate}
-
-\subsection{Extended Regular Expressions}
-
-`Extended' regular expressions introduce a few new meta characters
-which make certain kinds of regular expression more convenient to
-type. They eliminate back-references, which makes other kinds of
-regular expression impossible.
-
-\begin{enumerate}
-\item[+]Kleene closure. matches 1 or more of whatever the preceding character
-or group of characters matches. `.+' matches any string of non-zero length.
-`a+' matches `a', `aa', {\it etc}.. The regular expression engine will take
-the first, longest match for Kleene closure. `a+' will match the
-first three characters of `aaabcaa';
-\item[?]Matches 0 or 1 of whatever the preceding character or group of
-characters matches. `\char`\^noodles?\$' matches `noodle' or `noodles';
-\item[(]Begins a group. The regular expression which
-appears between ( and ) is treated
-as a unit with respect to Kleene closure and interval operations.
-`(abc)*' matches `', `abc', `abcabc',
-{\it etc}.;
-Group contents can also be returned to the caller by the regular
-expression matching functions;
-\item[)]Ends a group;
-\item[|]Branching: divides the regular expression (or group within
-a regular expression) into alternatives. The regular expression will
-match the first, longest match of any of the alternatives. `cat|dog'
-will match either `cat' or `dog'. It will match the first three
-characters of `cats and dogs'. `\char`\^\ *(int|long) +[a-z\textunderscore][a-z0-9A-Z\textunderscore]*;'
-matches the declaration of an int or long variable in a C program;
-\item[\char`\{]Interval: \char`\{ must
-be followed by one of a whole number $w_1$, a whole number $w_2$ and a comma,
-or two whole numbers $w_3$ and $w_4$, $w_3<w_4$ separated by a comma.
-The interval constrains the preceding character
-or group to match exactly $w_1$ instances, $w_2$ or more
-instances, or between $w_3$ and $w_4$ instances, inclusive, depending on
-the syntax used. `a\char`\{3\char`\}' matches
-the first three characters of `aaaaaa'.
-`a\char`\{3,\char`\}' matches
-all the characters of `aaaaaa' but does not match `aa'.
-`a\char`\{3,4\char`\}' matches
-the first four characters of `aaaaaa' but does not match `aa'. Note that
-Object Rexx supports only the first interval syntax;
-\item[\char`\}]Closes an interval.
-\end{enumerate}
-
-\subsection{Alternation Sets}
-
-\label{sec:alternation}
-Alternation is a useful but seemingly confusing aspect of regular
-expression syntax. At its simplest, a set of characters delimited by
-[ and ] matches any character in the set. [abc] matches any of
-a, b, or c. The alternation set is treated as a single unit for
-the purposes of Kleene closure and interval operations.
-
-Alternation sets have a different set of meta characters from the
-rest of the RE. For instance, `.' is an ordinary character within
-an alternation set, but `\char`\^', `-', and `]' have special meanings.
-
-\begin{enumerate}
-\item[\char`\^]When it appears at the very start of the alternation set,
-`\char`\^' inverts the set. `[\char`\^abc]' matches any character {\it but}
-a, b, or c. When it appears elsewhere in the set, it has no special
-meaning;
-\item[-]When it appears between two other characters, - represents all
-the characters which appear between those two characters in the current
-character set. On ASCII systems, `[a-z]' represents any lower-case
-letter. - represents itself when placed at either the start or the end
-of the alternation set. `[\char`\^-]' represents any character but -. `[-+/*]'
-represents any arithmetic operator;
-\item[{]}]When it appears anywhere but at the start of the alternation
-set, ] terminates the set. `[\char`\^]]' represents any character but ].
-`[]a-z]' represents any lower-case letter or ].
-\end{enumerate}
-
-Since the use of character values and the use of the range operator
-results in definitions which are character-set- and
-natural-language-specific, POSIX defines classes of characters which can
-be used by name within alternation sets, by enclosing the names within
-`[:' and `:]'. These classes are:
-
-\begin{enumerate}
-\item[alnum]letters and numbers;
-\item[alpha]letters;
-\item[blank]space or tab;
-\item[cntrl]control characters;
-\item[digit]numbers;
-\item[graph]printable characters;
-\item[lower]lower-case letters;
-\item[print]printable characters;
-\item[punct]punctuation;
-\item[space]white space (including newlines, vertical tabs, {\it etc.});
-\item[upper]upper-case letters;
-\item[xdigit]hexadecimal digits.
-\end{enumerate}
-
-A C language identifier consists of a letter or underscore followed by
-any number of letters, digits, or underscores. This could be matched
-by the regular expression `[a-zA-Z\textunderscore][a-zA-Z0-9\textunderscore]*', however this will
-work only on machines that use the ASCII character set. The same
-regular expression using character classes is
-`[[:alpha:]\textunderscore][[:alnum:]\textunderscore]*'.
-
-Note that the POSIX treatment of character classes is different from
-the Object Rexx treatment.
-
-\section{Function Definitions}
-
-\subsection{Introduction}
-
-Normal use of RexxRE is to register the library using ReLoadFuncs(\,),
-compile one or more regular expressions using ReComp(\,), then match
-the compiled regular expressions against input strings using ReExec(\,).
-Alternatively, ReParse(\,) can be used to perform an operation similar
-to the parse value instruction, using regular expressions for the parse
-template.
-
-Compiling regular expressions is optional, but you should
-note that there is no way to determine whether the regular expression
-was compiled correctly by either ReExec(\,) or ReParse(\,), and
-compiling regular expressions provides a performance gain unless
-the regular expression match is performed only once.
-
-If an error does occur while compiling the regular expression, useful
-diagnostic may be retrieved by calling ReError(\,). Once the compiled
-regular expression is no longer needed, it can be released using
-ReFree(\,).
-
-
-
-\subsection{ReLoadFuncs}
-
-\begin{verbatim}
-ReLoadFuncs()
-\end{verbatim}
-
-ReLoadFuncs(\,) registers all the other routines in RexxRE with the Rexx
-interpreter. This registration takes less work on your part than
-registering each individual function using RxFuncAdd(\,), but you can
-register the functions you intend to use individually if that makes you feel
-better.
-
-\subsection{ReDropFuncs}
-
-\begin{verbatim}
-ReDropFuncs()
-\end{verbatim}
-
-ReDropFuncs(\,) unregisters all the routines in RexxRE. It is safe
-to do this even if the functions were not registered using
-ReLoadFuncs(\,). With Regina and likely most other interpreters, function
-registration ends when the Rexx process terminates in any case,
-however with IBM's interpreters, function registration persists until
-the functions are unregistered or the machine is rebooted, so
-it's good practice to call ReDropFuncs(\,) at the end of each program.
-
-\subsection{ReVersion}
-
-\begin{verbatim}
-ReVersion() -> version string
-\end{verbatim}
-
-ReVersion(\,) reports the version number of the library in the format
-{\it version}.\penalty\exhyphenpenalty{\it release}.\penalty\exhyphenpenalty{\it modification}. It's often
-useful to have this information when investigating bugs.
-
-Typically,
-I change the {\it modification} level whenever I make a bug-fix
-release, I change the {\it release} number whenver I add new
-functions, and I change the {\it version} number when I add
-dramatically new functionality. This might happen if I elected
-to support the Object Rexx regular expression syntax, for instance.
-
-\subsection{ReComp}
-
-\begin{verbatim}
-ReComp(re, flags) -> cre
-\end{verbatim}
-
-\label{sec:recomp}
-ReComp(\,) compiles the regular expression {\it re} into the compiled
-regular expression {\it cre}. By default, {\it re} is a `basic'
-regular expression, and it is compiled to match case-insensitively,
-meaning lower-case letters in {\it re} will match the corresponding upper-
-and lower-case letters.
-
-You need to call ReComp(\,) only once per regular expression, and
-you can have any number of compiled regular expressions active at any time.
-Both ReExec(\,) and ReParse(\,) accept uncompiled regular expressions as
-well as compiled regular expressions, so you may leave out the
-compilation step if you don't need to perform repeated matches
-against the same RE.
-
-You should release the memory allocated for the regular expression by
-calling ReFree(\,) when you no longer need it.
-
-{\it Flags} can be any combination of
-
-\begin{enumerate}
-\item[x]means {\it re} is an `extended' regular expression;
-\item[c]to get case-sensitive matches
-\item[s]means that only the status of the match will be returned from
-ReExec(\,). When this flag is given, ReExec(\,) will return as soon as some
-match of the regular expression has been achieved.
-Normally the regular expression engine will continue processing
-until it finds the first, longest match, and it returns either the
-matched strings or their position. Do not pass the {\it matches} argument
-to ReExec(\,) if you pass the `s' flag to ReComp(\,), and do not
-use a compiled regular expression which used the `s' flag as an argument
-to ReParse(\,);
-\item[n]Treat new-lines as match delimiters. Normally, a new-line in
-a target string is treated like any other control character, but
-when the regular expression is compiled with the `n' flag, new-lines
-are never matched by the regular expression and are used to delimit
-RE anchors ({\it e.g.}, `cat\$' would match `cat[newline]').
-\end{enumerate}
-
-If the regular expression compiles successfully, the first character of
-{\it cre} will be 0. Otherwise, it will be 1. You can test it like
-this:
-\begin{verbatim}
-cre = ReComp('cat$', 'c')
-if left(cre, 1) then do
-  say 'failed to compile RE cat$:' ReError(cre)
-  call ReFree cre
-  exit 1
-  end 
-\end{verbatim}
-
-{\samepage
-
-\subsection{ReExec}
-
-\begin{verbatim}
-ReExec(cre, string[, matches[, flags]]) -> 0 or 1
-\end{verbatim}
-
-ReExec(\,) searches the target string {\it string} for the first,
-longest substring which can be represented by the regular expression {\it cre}.
-{\it cre} ought usually to have been compiled by a previous call to ReComp,
-however it can also be a string representation of the RE, at the cost
-of performance.
-
-}
-
-{\it matches} is the name of a stem used to store information about
-the match. On successful return, {\it matches}.0 contains the number
-of parenthesized sub-expressions of {\it cre}.
-Each of {\it matches}.1 to {\it matches}.({\it matches}.0)
-contains the string that matches the corresponding parenthesised
-subexpression of {\it cre}. {\it matches}.!match  contains the string which
-matches the whole of {\it cre}. Do not pass a value for {\it matches}
-if {\it cre} was compiled with the `s' flag.
-
-{\it flags} can be any combination of the flag arguments to ReComp(\,)
-and these values:
-\begin{enumerate}
-\item[p]instead of returning strings in {\it matches}, return the
-offset and length of each match within {\it string}, separated by
-a single space;
-\item[b]the string does not start at the beginning of a line. This
-affects \char`\^\ processing;
-\item[e]the string does not end at the end of a line. This affects
-\$ processing.
-\end{enumerate}
-
-ReComp(\,) flags are used only when compiling a string-format regular
-expression. I don't advise doing this as it's usually faster
-to use the result of ReComp(\,), and there's no way to test for
-errors in regular expression compilation when it's done by ReExec(\,).
-In any case, passing, for instance `c' as a flag to ReExec(\,) will
-have no effect if {\it cre} is a compiled regular expression.
-
-ReExec returns 1 if a match was found for the regular expression, and
-0 otherwise.
-
-\subsection{ReError}
-
-\begin{verbatim}
-ReError(cre) -> error string
-\end{verbatim}
-
-ReError(\,) takes a compiled regular expression returned from a failed call
-to ReComp(\,) and returns a string which explains the problem.
-
-\subsection{ReFree}
-
-\begin{verbatim}
-ReFree(cre[, cre, ...])
-\end{verbatim}
-
-ReFree(\,) releases memory used to hold the compiled regular expressions {\it
-cre}. For complicated regular expressions, memory usage can be substantial,
-and it makes sense to call ReFree(\,) as soon as you no longer need the RE.
-
-\subsection{ReParse}
-
-\begin{verbatim}
-ReParse(cre, string, [flags], varname[, varname, ...]) -> 0 or 1
-\end{verbatim}
-
-ReParse(\,) attempts to provide `parse value'-like functionality using regular
-expressions. The arguments are a regular expression, which should normally
-have been compiled by ReComp(\,), a target string, flags that affect the
-processing of the regular expression, and a list of variable names. The
-regular expression is used to divide the target string into fields, which are
-then assigned to the variables as described below.
-
-By default, {\it cre} represents a field delimiter, and each field is assigned
-to the corresponding variable. As with the parse instruction, if more data is
-available than there are variable names, all the data at the end of {\it
-string} is written to the final variable in the list. These lines should be
-equivalent
-\begin{verbatim}
-call ReParse '  *', value, , a, b, c
-parse value value with a b c
-\end{verbatim}
-
-{\it Flags} can be any combination of the flag arguments to ReComp(\,)
-and these values, which determine how fields are assigned to variables:
-
-\begin{enumerate}
-
-\item[d]{\it cre} represents the delimiter between each field. If the
-delimiter appears at the start of {\it string}, then the first field has zero
-length. If the number of variables is less than then number of delimited
-fields, the last variable in the list is assigned the remaining portion of the
-string, excluding the leading delimiter. If the number of variables is greater
-than the the number of delimited fields, all the unmatched variables are set
-to zero-length. This is the default;
-
-\item[v]{\it cre} represents the format of a field. If each field consists of
-integer data, {\it cre} might be `[0-9]+'. If $n$ variable names are passed as
-arguments, up to the first $n - 1$ field values are assigned to the
-corresponding variables from the list. The $n$th variable is always assigned
-the portion of {\it string} which remains after the field assignments. It can
-then be used for further parse operations. If there are fewer than $n$ fields,
-any variables which do not correspond to a field are set to zero length;
-
-\item[s]each field corresponds to a parenthesised sub-expressions. If the
-number of variables is less than the number of sub-expressions, the extra
-matches will be thrown away. Note that this is essentially the opposite
-meaning to the `s' flag of ReComp(\,);
-
-\item[t]{\it varname} is the name of a stem variable, and fields are written
-to the stem using the numeric convention.
-
-\end{enumerate}
-
-The ReComp(\,) flags are used only if {\it cre} is a string representation
-of the RE.
-You should compile any regular expression which will be used in the
-parse or exec routines more than once, since the performance is better.
-You should also compile any regular expression which is created
-dynamically or input by the end user, in order to validate its
-compilation.
-
-\subsubsection{Examples}
-
-Parsing a syslog entry:
-
-\begin{verbatim}
-  /* here's a syslog entry */
-  data = 'Apr 29 11:55:17  su: ptjm to root on /dev/ttyp2'
-
-  /* this RE matches some characters which are not :, a space,
-   * two digits forming sub-expression 1, a colon, two digits
-   * forming sub-expression 2, a colon, two digits forming
-   * sub-exression 3, any number of spaces, some bunch of
-   * non-colon characters forming sub-expression 4, a colon, a space,
-   * and whatever's left in the target string, forming sub-expression 5 */
-  re = '[^:]+ ([0-9]{2}):([0-9]{2}):([0-9]{2}) +([^:]+): (.+)'
-
-  /* the parse call matches the sub-expressions to the variables
-   * hh, mi, ss, component, and msg, respectively */
-  call reParse re, data, 'xs', 'hh', 'mi', 'ss', 'component', 'msg'
-  /* now, hh = 11; mi = 55; ss = 17; component = 'su'
-          msg = 'ptjm to root on /dev/ttyp2' */
-
-  /* this RE matches any number of spaces and colons */
-  re = '[ :]{1,}'
-
-  /* the parse call matches each space-delimited expression to a
-   * variable */
-  call reParse re, data, , ., ., 'hh', 'mi', 'ss', 'component', 'msg'
-  /* now, hh = 11; mi = 55; ss = 17; component = 'su'
-          msg = 'ptjm to root on /dev/ttyp2' */
-
-  /* this RE matches any number of alpha-numerics */
-  rean = ReComp('[[:alnum:]]+', 'x')
-
-  /* this one matches any number of numerics */
-  ren = ReComp('[[:digit:]]+', 'x')
-
-  /* this one matches any number of non-spaces or colons */
-  re!sc = ReComp('[^ :]+', 'x')
-
-  /* throw away the date */
-  call reParse(rean, data, 'v', '.',  '.', data)
-  /* data = ' 11:55:17  su: ptjm to root on /dev/ttyp2' */
-
-  /* get the time */
-  call reParse(ren, data, 'v', 'hh', 'mi', 'ss', data)
-  /* data = '  su: ptjm to root on /dev/ttyp2' */
-
-  /* get the component */
-  call reParse(re!sc, data, 'v', 'component', data)
-
-  /* data = ': ptjm to root on /dev/ttyp2' */
-  msg = substr(data, 2)
-  /* now, hh = 11; mi = 55; ss = 17; component = 'su'
-          msg = 'ptjm to root on /dev/ttyp2' */
-  call ReFree ren, rean, re!sc
-\end{verbatim}
-
-Flexible date processing:
-
-\begin{verbatim}
-parsedate: procedure
-mwre = ReComp('[[:alpha:]]+', 'x')
-mdre = ReComp('[[:digit:]]{1,2}', 'x')
-yre = ReComp('[[:digit:]]{4}', 'x')
-
-parse arg date
-
-pdate = date
-rdate = 'baddate'
-
-/* test for April 30 2003 */
-if ReParse(mwre, pdate, 'v', 'month', 'pdate') then do
-    if ReParse(mdre, pdate, 'v', 'day', 'pdate') then do
-        if ReParse(yre, pdate, 'v', 'year', 'pdate') then
-             rdate = year'/'mwords(month)'/'day
-        end
-    /* start over, trying 30 April 2003 */
-    if rdate = 'baddate' then do
-        pdate = date
-        if ReParse(mdre, pdate, 'v', 'day', 'pdate') then do
-            if ReParse(mwre, pdate, 'v', 'month', 'pdate') then do    
-                if ReParse(yre, pdate, 'v', 'year', 'pdate') then
-                     rdate = year'/'mwords(month)'/'right(day,2,'0')
-                end
-            end
-        end
-    end
-else do
-    /* test for 2003/04/30 */
-    pdate = date
-    if ReParse(yre, pdate, 'v', 'year', 'pdate') then do
-        if ReParse(mdre, pdate, 'v', 'month', 'pdate') then do    
-            if ReParse(mdre, pdate, 'v', 'day', 'pdate') then
-                rdate = year'/'right(month,2,'0')'/'right(day,2,'0')
-            end
-        end
-
-    /* test for 30/04/2003, then give up */
-    if rdate = 'baddate' then do
-        pdate = date
-        if ReParse(mdre, pdate, 'v', 'day', 'pdate') then do
-            if ReParse(mdre, pdate, 'v', 'month', 'pdate') then do    
-                if ReParse(yre, pdate, 'v', 'year', 'pdate') then
-                    rdate = year'/'right(month,2,'0')'/'right(day,2,'0')
-                end
-            end
-        end
-    end
-
-call ReFree mwre, yre, mdre
-return rdate
-\end{verbatim}
-
-\end{document}
Binary files rexxre/rexxtrans/rexxre.dll and rexxre-patch/rexxtrans/rexxre.dll differ
diff -ruN rexxre/rxproto.h rexxre-patch/rxproto.h
--- rexxre/rxproto.h	2003-05-01 11:15:22.000000000 +1200
+++ rexxre-patch/rxproto.h	1970-01-01 13:00:00.000000000 +1300
@@ -1,155 +0,0 @@
-/* definitions and prototypes for Rexx interface libraries
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS"
- * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
- * License for the specific language governing rights and limitations
- * under the License.
- *
- * The Original Code is regutil.
- *
- * The Initial Developer of the Original Code is Patrick TJ McPhee.
- * Portions created by Patrick McPhee are Copyright © 1998, 2001
- * Patrick TJ McPhee. All Rights Reserved.
- *
- * Contributors:
- *
- * $Header: C:/ptjm/rexx/rexxre/RCS/rxproto.h 1.2 2003/05/01 16:15:21 ptjm Rel $
- */
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-/* this is to define alloca appropriately. I rather wish ansi had defined
- * this useful function */
-
-#if defined(_WIN32)	/* microsoft C */
-# include <malloc.h>
-# define strcasecmp _stricmp
-#elif defined (AIX)
-# pragma alloca
-#elif !defined(__GNUC__)
-# include <alloca.h>
-#endif
-
-#define INCL_REXXSAA
-#ifdef __EMX__	/* emx under OS/2 */
-# include <os2.h>
-# define strcasecmp stricmp
-#elif defined(REXXTRANS)
-# include "rexxtrans.h"
-#else
-# include "rexxsaa.h"
-#endif
-
-/* a rexx api function has type RexxFunctionHandler, which takes the name of
- * the function, the number of arguments, an array of arguments, a pointer
- * to something else, and a pointer to the result string.
- * It returns 0 for success, and some other value for failure */
-
-#define rxfunc(x) APIRET APIENTRY x(PUCHAR fname, ULONG argc, PRXSTRING argv, PSZ pSomething, PRXSTRING result)
-
-/* return codes. 22 is rc for invalid call */
-#define NOMEMORY 5
-#define BADARGS 22
-#define BADGENERAL 40
-
-/* ensure there are enough args, and not too many */
-#define checkparam(f,t) if (argc < (f) || argc > (t)) return BADARGS
-
-/* make a null-terminated string from a rexx string */
-#define rxstrdup(y, x) do { y = (char *)alloca(RXSTRLEN(x)+1); memcpy(y,RXSTRPTR(x),RXSTRLEN(x)); y[RXSTRLEN(x)] = 0; } while (0)
-
-/* number of elements in a fixed-size array */
-#define DIM(x) (sizeof(x)/sizeof(*x))
-
-/* allocate and free the way the source engine does (only do this if there's
- * not enough room in strptr). For Regina, use malloc to allocate, but don't
- * free, since result->strptr points to static data. */
-#ifndef REXXALLOCATEMEMORY
-# ifdef __EMX__
-#  define REXXALLOCATEMEMORY DosAllocMem
-#  define REXXFREEMEMORY DosFreeMem
-# elif defined(OBJECTREXXW32)
-#  define REXXALLOCATEMEMORY GlobalAlloc
-#  define REXXFREEMEMORY GlobalFree
-# else
-#  define REXXALLOCATEMEMORY malloc
-#  define REXXFREEMEMORY free
-# endif
-#endif
-
-#ifdef RXAUTOBUFLEN
-# define DEFAULTSTRINGSIZE RXAUTOBUFLEN
-#else
-# define DEFAULTSTRINGSIZE 255
-#endif
-
-/* resize the result variable. The Rexx engine is responsible for
- * freeing the memory that was passed in. */
-#define rxresize(x, y) do { (x)->strlength = y;\
-	if ((x)->strlength > DEFAULTSTRINGSIZE) {\
-	   (x)->strptr = (char *)REXXALLOCATEMEMORY((x)->strlength);\
-	}\
-        if (!(x)->strptr) return NOMEMORY; } while (0)
-
-/* sometimes we want to return just a 0 or 1 to indicate success or
- * failure */
-#define result_zero() result->strlength = 1, *result->strptr = '0'
-#define result_one() result->strlength = 1, *result->strptr = '1'
-
-/* datatype: re-sizeable array of characters */
-typedef struct {
-    int count;
-    int ptr_alloc, char_alloc, char_used;
-    PRXSTRING array;
-    char *chardata;
-} chararray;
-
-
-/* set the special variable rc. We usually set it to either 0 or 1 */
-void set_rc(const char * const value, const int len);
-void rc_one();
-void rc_zero();
-
-/* set an arbitrary variable */
-void setavar(PRXSTRING varname, const char * const value, const int len);
-
-/* map an array to a stem variable */
-int setastem(PRXSTRING varname, const chararray * const values);
-int getastem(PRXSTRING varname, chararray * const values);
-
-/* retrieve portions of a numeric stem */
-int getstemtail(PRXSTRING varname, const int ind, chararray * const values);
-int setstemtail(PRXSTRING varname, const int ind, const chararray * const values);
-int getstemsize(PRXSTRING varname, int * count);
-int setstemsize(PRXSTRING varname, const int count);
-
-/* add a string to a character array */
-int cha_addstr(chararray *ca, const char * str, int len);
-/* add a string to a character array without copying the data */
-int cha_adddummy(chararray *ca, const char * str, int len);
-
-chararray * new_chararray(void);
-void delete_chararray(chararray * );
-
-/* how many micro-seconds in a string */
-int rxuint(PRXSTRING ptime);
-int rxint(PRXSTRING ptime);
-#ifdef _WIN32
-int sleep(unsigned usecs);
-int usleep(unsigned usecs);
-#else
-char * strupr(char * s);
-char * strlwr(char * s);
-#endif
-
-#ifndef min
-# define min(x,y) ((x) < (y) ? (x) : (y))
-#endif
diff -ruN rexxre/rxsupport.c rexxre-patch/rxsupport.c
--- rexxre/rxsupport.c	2003-05-01 10:48:46.000000000 +1200
+++ rexxre-patch/rxsupport.c	1970-01-01 13:00:00.000000000 +1300
@@ -1,642 +0,0 @@
-/* support functions which set rexx variables
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS"
- * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
- * License for the specific language governing rights and limitations
- * under the License.
- *
- * The Original Code is regutil.
- *
- * The Initial Developer of the Original Code is Patrick TJ McPhee.
- * Portions created by Patrick McPhee are Copyright © 1998, 2001
- * Patrick TJ McPhee. All Rights Reserved.
- *
- * Contributors:
- *
- * $Header: C:/ptjm/rexx/rexxre/RCS/rxsupport.c 1.2 2003/05/01 15:48:46 ptjm Rel $
- */
-#include "rxproto.h"
-
-#include <time.h>
-#include <ctype.h>
-#ifndef _WIN32
-# include <sys/param.h>
-#else
-# define MAXPATHLEN _MAX_PATH
-#endif
-
-
-/* it's preferable to set these things in one big blow, but sometimes
- * you have to do it one-off. */
-void set_rc(const char * const value, const int len)
-{
-    SHVBLOCK avar;
-    
-    avar.shvnext = NULL;
-    avar.shvname.strptr = "RC";
-    avar.shvname.strlength = 2;
-    avar.shvvalue.strptr = (char *)value;
-    avar.shvvalue.strlength = len;
-    avar.shvcode = RXSHV_SET;
-    RexxVariablePool(&avar);
-}
-
-
-void rc_one()
-{
-    set_rc("1", 1);
-}
-
-void rc_zero()
-{
-    set_rc("0", 1);
-}
-
-void setavar(PRXSTRING varname, const char * const value, const int len)
-{
-    SHVBLOCK avar;
-    
-    avar.shvnext = NULL;
-    avar.shvname.strptr = varname->strptr;
-    avar.shvname.strlength = varname->strlength;
-    avar.shvvalue.strptr = (char *)value;
-    if (len == -1)
-       avar.shvvalue.strlength = strlen(value);
-    else
-       avar.shvvalue.strlength = len;
-    avar.shvcode = RXSHV_SYSET;
-    RexxVariablePool(&avar);
-}
-
-/* given a stem name, find out the value of the .0 member */
-int getstemsize(PRXSTRING varname, int * count)
-{
-   char * nameptr = alloca(varname->strlength+2), valbuf[11];
-   SHVBLOCK stem;
-
-   /* set up the .0 member */
-   stem.shvname.strptr = nameptr;
-   memcpy(nameptr, varname->strptr, varname->strlength);
-
-   if (nameptr[varname->strlength-1] == '.') {
-      nameptr[varname->strlength] = '0';
-      stem.shvname.strlength = varname->strlength + 1;
-   }
-   else {
-      memcpy(nameptr+varname->strlength, ".0", 2);
-      stem.shvname.strlength = varname->strlength + 2;
-   }
-
-   stem.shvvalue.strptr = valbuf;
-   stem.shvvalue.strlength = stem.shvvaluelen = sizeof(valbuf);
-   stem.shvcode = RXSHV_SYFET;
-   stem.shvnext = NULL;
-
-   if (!RexxVariablePool(&stem)) {
-      valbuf[stem.shvvalue.strlength] = 0;
-      *count = atoi(valbuf);
-      return 0;
-   }
-   else {
-      *count = 0;
-      return 1;
-   }
-}
-
-
-/* given a stem name, set the value of the .0 member */
-int setstemsize(PRXSTRING varname, const int count)
-{
-   char * nameptr = alloca(varname->strlength+2), valbuf[11];
-   SHVBLOCK stem;
-
-   /* set up the .0 member */
-   stem.shvname.strptr = nameptr;
-   memcpy(nameptr, varname->strptr, varname->strlength);
-
-   if (nameptr[varname->strlength-1] == '.') {
-      nameptr[varname->strlength] = '0';
-      stem.shvname.strlength = varname->strlength + 1;
-   }
-   else {
-      memcpy(nameptr+varname->strlength, ".0", 2);
-      stem.shvname.strlength = varname->strlength + 2;
-   }
-
-   stem.shvvalue.strptr = valbuf;
-   stem.shvvalue.strlength = stem.shvvaluelen = sprintf(valbuf, "%d", count);
-   stem.shvcode = RXSHV_SYSET;
-   stem.shvnext = NULL;
-
-   if (!RexxVariablePool(&stem)) {
-      return 0;
-   }
-   else {
-      return 1;
-   }
-}
-
-
-/* given an array of strings and the name of a stem variable, set the stem
- * variable to match the strings */
-int setastem(PRXSTRING varname, const chararray * const values)
-{
-    SHVBLOCK *astem,
-	    stem0[2];
-    register int i;
-    int namelen = varname->strlength + 12, orignamelen, count;
-    char * namebuf,
-	 * origname, valbuf[11], *nameptr;
-
-    namebuf = malloc(namelen * (values->count+1));
-
-    if (values && values->count) {
-        count = values->count;
-	astem = malloc(values->count*sizeof(*astem));
-	memset(astem, 0, values->count * sizeof(*astem));
-    }
-    else {
-       astem = NULL;
-       count = 0;
-    }
-
-    memset(stem0, 0, sizeof(stem0));
-
-    if (varname->strptr[varname->strlength-1] == '.') {
-       rxstrdup(origname, *varname);
-       orignamelen = varname->strlength;
-    }
-    else {
-       origname = alloca(varname->strlength+2);
-       memcpy(origname, varname->strptr, varname->strlength);
-       origname[varname->strlength] = '.';
-       origname[varname->strlength+1] = 0;
-       orignamelen = varname->strlength+1;
-    }
-    strupr(origname);
-    nameptr = namebuf;
-
-    /* drop the stem */
-    stem0[0].shvnext = stem0+1;
-    stem0[0].shvname.strptr = origname;
-    stem0[0].shvname.strlength = orignamelen;
-    stem0[0].shvcode = RXSHV_DROPV;
-
-    /* set up the .0 member */
-    stem0[1].shvnext = astem;
-    stem0[1].shvname.strptr = nameptr;
-    stem0[1].shvname.strlength = sprintf(nameptr, "%s%d", origname, 0);
-    stem0[1].shvvalue.strptr = valbuf;
-    stem0[1].shvvalue.strlength = sprintf(valbuf, "%d", count);
-    stem0[1].shvcode = RXSHV_SYSET;
-
-    nameptr += namelen;
-
-    for (i = 0; i < count; i++) {
-	astem[i].shvnext = astem+i+1;
-	astem[i].shvname.strptr = nameptr;
-	astem[i].shvname.strlength = sprintf(nameptr, "%s%d", origname, i+1);
-	astem[i].shvvalue = values->array[i];
-	astem[i].shvcode = RXSHV_SYSET;
-	nameptr += namelen;
-    }
-
-    if (i)
-	astem[i-1].shvnext = NULL;
-
-    RexxVariablePool(stem0);
-    free(namebuf);
-    if (astem)
-	free(astem);
-
-    return 0;
-}
-
-/* given an array of strings, a one-based index, and the name of a stem
- * variable, set the stem variable to match the strings, starting at the
- * index position. Leave any other values in the stem alone. Set the
- * length of the stem to ind+values->count. */
-int setstemtail(PRXSTRING varname, const int ind, const chararray * const values)
-{
-   SHVBLOCK stem, * vars;
-   register int i, j;
-   int count, dcount;
-   int namelen = varname->strlength + 12;
-   char * origname, *nameptr;
-
-   if (varname->strptr[varname->strlength-1] == '.') {
-      rxstrdup(origname, *varname);
-   }
-   else {
-      origname = alloca(varname->strlength+2);
-      memcpy(origname, varname->strptr, varname->strlength);
-      origname[varname->strlength] = '.';
-      origname[varname->strlength+1] = 0;
-   }
-   strupr(origname);
-
-
-   /* set the stem size if it's shrinking */
-   getstemsize(varname, &count);
-
-   /* and get rid of the ones we won't be needing any more */
-   dcount =  count - (ind + values->count)+1;
-
-   if (dcount > 0 && ind == 1) {
-      /* can simply drop the stem if we're starting at 1 */
-      stem.shvname.strptr = origname;
-      stem.shvname.strlength = strlen(origname);
-      stem.shvcode = RXSHV_DROPV;
-      stem.shvnext = NULL;
-      RexxVariablePool(&stem);
-
-      setstemsize(varname, ind+values->count-1);
-   }
-
-   else if (dcount > 0) {
-
-      setstemsize(varname, ind+values->count-1);
-
-      /* get rid of the ones we won't need any more */
-      vars = calloc(dcount, sizeof(*vars)+namelen);
-      if (vars) {
-         for (i = 0, j = ind + values->count; i < dcount; i++, j++) {
-            nameptr = ((char *)(vars+dcount)) + i * namelen;
-            vars[i].shvname.strptr = nameptr;
-            vars[i].shvname.strlength = sprintf(nameptr, "%s%d", origname, j);
-            vars[i].shvcode = RXSHV_DROPV;
-            vars[i].shvnext = vars+i+1;
-         }
-         vars[i-1].shvnext = NULL;
-         RexxVariablePool(vars);
-         free(vars);
-      }
-      else {
-         nameptr = alloca(namelen);
-         
-         stem.shvname.strptr = nameptr;
-         stem.shvcode = RXSHV_DROPV;
-         stem.shvnext = NULL; 
-         
-         for (j = ind + values->count; j < count; j++) {
-            stem.shvname.strlength = sprintf(nameptr, "%s%d", origname, j);
-            RexxVariablePool(&stem);
-         }
-      }
-
-
-   }
-
-   vars = malloc(values->count * (sizeof(*vars)+namelen));
-
-
-   /* if we couldn't allocate enough space, do it one-by-one using stem */
-   if (vars == NULL) {
-      nameptr = alloca(namelen);
-         
-      stem.shvname.strptr = nameptr;
-      stem.shvcode = RXSHV_SYSET;
-      stem.shvnext = NULL;
-
-      for (i = 0; i < values->count; i++) {
-         stem.shvname.strlength = sprintf(nameptr, "%s%d", origname, i+ind);
-         stem.shvvalue = values->array[i];
-         
-         stem.shvret = 0;
-         RexxVariablePool(&stem);
-      }
-   }
-   else {
-      for (i = 0; i < values->count; i++) {
-         nameptr = (char *)(vars+values->count) + i * namelen;
-         
-         vars[i].shvname.strptr = nameptr;
-         vars[i].shvname.strlength = sprintf(nameptr, "%s%d", origname, i+ind);
-
-         vars[i].shvcode = RXSHV_SYSET;
-         vars[i].shvvalue = values->array[i];
-         vars[i].shvret = 0;
-
-         vars[i].shvnext = vars+i+1;
-      }
-
-      if (i)
-         vars[i-1].shvnext = NULL;
-
-      RexxVariablePool(vars);
-      free(vars);
-   }
-   return 0;
-}
-
-
-/* given a stem name, retrieve the values associated with that stem, starting
- * at index ind (1-based) and stick them in a chararray. I'm doing this by
- * retrieving one value at a time and adding it to the array using cha_addstr. */
-int getstemtail(PRXSTRING varname, const int ind, chararray * const values)
-{
-    SHVBLOCK stem, * vars;
-    register int i, count, vallen;
-    int namelen = varname->strlength + 12;
-    char * origname, valbuf[11], *nameptr, *valptr = NULL;
-    
-    if (!values)
-	return -1;
-
-    values->count = 0;
-
-    if (varname->strptr[varname->strlength-1] == '.') {
-       rxstrdup(origname, *varname);
-    }
-    else {
-       origname = alloca(varname->strlength+2);
-       memcpy(origname, varname->strptr, varname->strlength);
-       origname[varname->strlength] = '.';
-       origname[varname->strlength+1] = 0;
-    }
-    strupr(origname);
-
-    /* first, find out how many there are */
-    nameptr = alloca(namelen);
-    memset(&stem, 0, sizeof(stem));
-
-    /* set up the .0 member */
-    stem.shvname.strptr = nameptr;
-    stem.shvname.strlength = sprintf(nameptr, "%s%d", origname, 0);
-    stem.shvvalue.strptr = valbuf;
-    stem.shvvalue.strlength = stem.shvvaluelen = sizeof(valbuf);
-    stem.shvcode = RXSHV_SYFET;
-
-    RexxVariablePool(&stem);
-
-    /* there is no stem, so there is nothing to return */
-    if (stem.shvret & RXSHV_NEWV)
-      return 0;
-
-    valbuf[stem.shvvalue.strlength] = 0;
-    count = atoi(valbuf) - ind + 1;
-
-    /* likewise, if there is nothing to return, there is nothing
-     * to return */
-    if (count <= 0)
-      return 0;
-
-    vallen = 500;
-    vars = malloc(count*(sizeof(*vars)+namelen+vallen));
-
-    if (!vars) {
-       stem.shvname.strptr = nameptr;
-       stem.shvcode = RXSHV_SYFET;
-
-       vallen = 10000;
-       valptr = malloc(vallen);
-
-       stem.shvvalue.strptr = valptr;
-
-       for (i = 0; i < count; i++) {
-           stem.shvname.strlength = sprintf(nameptr, "%s%d", origname, i+ind);
-           stem.shvvaluelen = stem.shvvalue.strlength = vallen;
-
-           RexxVariablePool(&stem);
-           if (stem.shvret & RXSHV_TRUNC) {
-              vallen = stem.shvvaluelen;
-              valptr = realloc(valptr, vallen);
-              stem.shvret = 0;
-              stem.shvvalue.strptr = valptr;
-              i--;
-           }
-           else {
-              cha_addstr(values, stem.shvvalue.strptr, stem.shvvalue.strlength);
-           }
-       }
-    }
-
-    else {
-       valptr = (char *)(vars+count) + namelen*count;
-       for (i = 0; i < count; i++) {
-          nameptr = (char *)(vars+count) + namelen*i;
-          vars[i].shvname.strptr = nameptr;
-          vars[i].shvcode = RXSHV_SYFET;
-          vars[i].shvvalue.strptr = valptr+i*vallen;
-          vars[i].shvvaluelen = vallen;
-          vars[i].shvret = 0;
-
-          vars[i].shvname.strlength = sprintf(nameptr, "%s%d", origname, i+ind);
-          vars[i].shvvaluelen = vars[i].shvvalue.strlength = vallen;
-          vars[i].shvnext = vars+i+1;
-       }
-       vars[i-1].shvnext = NULL;
-       valptr = NULL;
-
-       RexxVariablePool(vars);
-
-       /* add strings to array. If any string is truncated, knock up the
-        * buffer and try it again */
-       for (i = 0; i < count; i++) {
-           if (vars[i].shvret & RXSHV_TRUNC) {
-              vars[i].shvnext = NULL;
-
-              /* re-allocate only if we haven't already made the buffer big
-               * enough */
-              if (vallen < vars[i].shvvaluelen) {
-                 vallen = vars[i].shvvaluelen;
-                 valptr = realloc(valptr, vallen);
-              }
-
-              vars[i].shvvalue.strptr = valptr;
-              vars[i].shvvaluelen = vallen;
-              RexxVariablePool(vars+i);
-           }
-
-           cha_addstr(values, vars[i].shvvalue.strptr, vars[i].shvvalue.strlength);
-       }
-
-       free(vars);
-    }
-
-
-    if (valptr)
-       free(valptr);
-
-    return 0;
-}
-
-
-/* given a stem name, retrieve the values associated with that stem and stick
- * them in a chararray. This is equivalent to getstemtail with index 1. */
-int getastem(PRXSTRING varname, chararray * const values)
-{
-   return getstemtail(varname, 1, values);
-}
-
-
-/* return the number of seconds in the string pointed to by ptime */
-int rxint(PRXSTRING ptime)
-{
-   char * timestr;
-   register int sec;
-
-   rxstrdup(timestr, ptime[0]);
-   sec = atoi(timestr);
-
-   return sec;
-}
-
-/* return the number of microseconds in the string pointed to by ptime */
-int rxuint(PRXSTRING ptime)
-{
-   char * timestr, digits[7];
-   register int usec = 0;
-
-   rxstrdup(timestr, ptime[0]);
-
-   /* now look for a decimal place */
-   timestr = strchr(timestr, '.');
-   if (timestr++) {
-      if (strlen(timestr) >= 6) timestr[6] = 0;
-      else {
-         memset(digits, '0', sizeof(digits));
-         digits[6] = 0;
-         memcpy(digits, timestr, strlen(timestr));
-         timestr = digits;
-      }
-      usec = atoi(timestr);
-   }
-
-   return usec;
-}
-
-
-#ifndef _WIN32
-/* convert a string to lower case */
-char * strlwr(register char * s)
-{
-    register char * t = s;
-
-    while (*t) {
-	*t = tolower(*t);
-	t++;
-    }
-
-   return s;
-}
-
-char * strupr(register char * s)
-{
-    register char * t = s;
-
-    while (*t) {
-	*t = toupper(*t);
-	t++;
-    }
-
-   return s;
-}
-
-#endif
-
-#define INITPTR 1000
-int cha_addstr(chararray *ca, const char * str, int len)
-{
-    if (ca->count >= ca->ptr_alloc) {
-	ca->ptr_alloc += INITPTR;
-	ca->array = realloc(ca->array, ca->ptr_alloc*sizeof(*ca->array));
-	if (ca->array == NULL) {
-            ca->ptr_alloc = 0;
-            ca->count = 0;
-	    return -1;
-         }
-    }
-    if ((ca->char_used+len+1) >= ca->char_alloc) {
-	ca->char_alloc = ca->char_used+len+INITPTR*MAXPATHLEN;
-	ca->chardata = realloc(ca->chardata, ca->char_alloc);
-
-	if (ca->chardata == NULL) {
-            ca->char_alloc = 0;
-	    return -1;
-        }
-
-        /* need to reset all the pointers ... */
-        else if (ca->count && ca->chardata != ca->array[0].strptr) {
-           register int i, len = 0;
-           for (i = 0; i < ca->count; i++) {
-              ca->array[i].strptr = ca->chardata + len;
-              len += ca->array[i].strlength + 1;
-           }
-        }
-
-    }
-
-    ca->array[ca->count].strlength = len;
-    ca->array[ca->count].strptr = ca->chardata+ca->char_used;
-    memcpy(ca->array[ca->count++].strptr, str, len);
-    ca->char_used += len+1;
-    ca->chardata[ca->char_used] = 0;
-
-    return 0;
-}
-
-/* add a string without copying the data. This is more efficient,
- * but you have to be careful not to throw away the data before you're done
- * with the array. */
-int cha_adddummy(chararray *ca, const char * str, int len)
-{
-    if (ca->count >= ca->ptr_alloc) {
-	ca->ptr_alloc += INITPTR;
-	ca->array = realloc(ca->array, ca->ptr_alloc*sizeof(*ca->array));
-	if (ca->array == NULL) {
-            ca->ptr_alloc = 0;
-            ca->count = 0;
-	    return -1;
-         }
-    }
-
-    ca->array[ca->count].strlength = len;
-    ca->array[ca->count++].strptr = (unsigned char *)str;
-
-    return 0;
-}
-
-chararray * new_chararray(void)
-{
-    chararray * ca;
-
-    ca = malloc(sizeof(*ca));
-
-    if (!ca)
-	return NULL;
-
-    /* allocate 1000 pointers by default. These point into one big buffer,
-     * which we allocate separately from the points -- a chararray has four
-     * mallocs, instead of one per pointer (on the other hand, we'll have
-     * some big chunks of data to realloc ...) */
-    ca->ptr_alloc = INITPTR;
-    ca->array = malloc(INITPTR*sizeof(*ca->array));
-    ca->char_alloc = INITPTR*MAXPATHLEN;
-    ca->chardata = malloc(INITPTR*MAXPATHLEN);
-    ca->count = 0;
-    ca->char_used = 0;
-
-    if (!ca->chardata || !ca->array) {
-	if (ca->chardata) free(ca->chardata);
-	if (ca->array) free(ca->array);
-	free(ca);
-	ca = NULL;
-    }
-
-    return ca;
-}
-
-void delete_chararray(chararray * ca)
-{
-    if (!ca) return;
-
-    if (ca->array) free(ca->array);
-    if (ca->chardata) free(ca->chardata);
-    free(ca);
-}
Binary files rexxre/win32/rexxre.dll and rexxre-patch/win32/rexxre.dll differ
